<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <meta name="giscus:backlink" content="https://chebread.github.io/post/python-객체-클래스">

    <title>[Python] 객체, 클래스 | 차한음 블로그</title>
    <meta name="description" content="파이썬의 모든 것은 객체다 파이썬의 모든 것은 객체다. 하지만 파이썬은 특수 구문을 이용해서 대부분의 객체를 숨긴다. num = 7을 입력했을 때 7이 담긴 정수 유형의 객체를 생...">
    <meta name="author" content="차한음">
    <link rel="canonical" href="https://chebread.github.io/">

    <meta property="og:title" content="[Python] 객체, 클래스 | 차한음 블로그">
    <meta property="og:description" content="파이썬의 모든 것은 객체다 파이썬의 모든 것은 객체다. 하지만 파이썬은 특수 구문을 이용해서 대부분의 객체를 숨긴다. num = 7을 입력했을 때 7이 담긴 정수 유형의 객체를 생...">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://chebread.github.io/post/python-객체-클래스">
    <meta property="og:site_name" content="차한음 블로그">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="[Python] 객체, 클래스 | 차한음 블로그">
    <meta name="twitter:description" content="파이썬의 모든 것은 객체다 파이썬의 모든 것은 객체다. 하지만 파이썬은 특수 구문을 이용해서 대부분의 객체를 숨긴다. num = 7을 입력했을 때 7이 담긴 정수 유형의 객체를 생...">

    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "headline": "[Python] 객체, 클래스 | 차한음 블로그",
        "author": {
            "@type": "Person",
            "name": "차한음"
        },
        "publisher": {
            "@type": "Organization",
            "name": "차한음",
        },
        "datePublished": "2025-05-30",
        "description": "파이썬의 모든 것은 객체다 파이썬의 모든 것은 객체다. 하지만 파이썬은 특수 구문을 이용해서 대부분의 객체를 숨긴다. num = 7을 입력했을 때 7이 담긴 정수 유형의 객체를 생..."
    }
    </script>

    <link rel="stylesheet" href="/styles/reset.css" />
    <link rel="stylesheet" href="/styles/layout.css" />
    <link rel="stylesheet" href="/styles/color-palette.css">
    <link rel="stylesheet" href="/styles/chroma.css">

    <link rel="stylesheet" href="/styles/github-markdown.css">
    <link rel="stylesheet" href="/styles/post.css">

    <link rel="icon" href="/favicons/favicon.ico" sizes="any">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    <link rel="apple-touch-icon" href="/favicons/apple-touch-icon.png">
</head>
<body>
    <div class="root">
        <div class="post">
           <nav class="post-nav">
                <a href="/" class="">
                    <span>홈</span>
                </a>
                <a href="/about" class="">
                    <span>어바웃</span>
                </a>
                <a href="/posts" class="active">
                    <span>포스트</span>
                </a>
            </nav>
            
            <main class="post-content">
                <header class="post-header">
                    <h1 class="post-title">[Python] 객체, 클래스</h1>
                    <p class="post-date"><time datetime="2025-05-30">2025년 05월 30일</time></p>
                    <p class="post-category"><a href="/posts/python-%eb%ac%b8%eb%b2%95-%ec%a0%95%eb%a6%ac">[Python 문법 정리]</a></p>
                </header>
                <div class="post-body">
                    <article class="markdown-body"><h2>파이썬의 모든 것은 객체다</h2>
<p>파이썬의 모든 것은 객체다.
하지만 파이썬은 특수 구문을 이용해서 대부분의 객체를 숨긴다.
num = 7을 입력했을 때 7이 담긴 정수 유형의 객체를 생성하고 객체 참조를 num에 할당한다.</p>
<h2>객체란 무엇인가?</h2>
<p><strong>객체(object)는 데이터(변수, 속성(attribute))와 코드(함수, 메서드(method))를 포함하는 커스텀 자료구조다.</strong>
객체는 어떤 구체적인 것의 유일한 인스턴스(instance)를 나타낸다. =&gt; 파이썬에서 어떤 클래스를 정의하고 그 클래스로부터 실제 데이터를 담고 동작할 수 있는 '실체'를 만들면, 그 실체를 '객체'라고 부르며 동시에 그 클래스의 '인스턴스'라고 부른다는 의미이다.
인스턴스(Instance)란 특정 클래스로부터 만들어진 객체를 의미한다.</p>
<p>7이라는 값을 가진 정수 객체는 덧셈이나 곱셈 같은 계산을 쉽게 해주는 객체다.
이것은 파이썬의 어딘가에 7이 속하는 정수 클래스가 있다는 뜻이다.
문자열 'cat', 'duck'도 객체이고, 'cat', 'duck'은 capitalize() 같은 문자열 매서드를 가지고 있다. =&gt; 그래서 메서드를 가지고 있는 거다. 문자열이 객체이기 때문이다</p>
<p>모든 객체는 리스트, 튜플, 딕셔너리, 셋의 요소로 사용할 수 있다.
모든 객체를 인수로 전달할 수 있고, 함수에서 그 결과를 반환할 수 있다.</p>
<blockquote>
<p>참고: 인스턴스 필드: <code>__init__()</code> 으로 정의하는 인스턴스의 속성
클래스 필드: 클래스 속성</p>
</blockquote>
<h2>인스턴스</h2>
<p>인스턴스(Instance)란 특정 클래스로부터 만들어진 객체를 의미한다.</p>
<h2>클래스 선언하기: class</h2>
<p>새 객체를 생성하기 위해서 객체에 포함된 내용을 나타내는 클래스(class)를 정의한다.
<strong>즉, 클래스로 객체를 생성한다.</strong></p>
<blockquote>
<p>사용자가 만든 객체는 특별한 조치를 취하지 않으면 기본적으로 가변(mutable)입니다. 그러나, dataclass로 불변 처럼 만들 수 있다.</p>
</blockquote>
<p>객체는 상자이고, 클래스는 상자를 만드는 틀이다.
문자열은 문자열 객체를 만드는 내장된 클래스다.
파이썬은 리스트, 딕셔너리 등을 포함한 다른 표준 데이터 타입을 생성하는 내장 클래스가 많이 있다.</p>
<p>커스텀 객체를 생성하기 위해 먼저 class 키워드로 클래스를 정의한다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cat</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">pass</span>
</span></span></code></pre><p>또는</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cat</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">pass</span>
</span></span></code></pre><p>방식으로 빈 클래스를 생성할 수 있다.</p>
<p>class 이름 뒤에는 괄호를 붙이거나 붙이지 않을 수 있다.
<strong>class 이름 뒤의 괄호의 의미는 상속한다는 뜻이다. 괄호 속 클래스 이름을 넣으면 해당 클래스로부터 상속을 받는 다는 뜻이다.</strong>
상속을 받지 않으면 괄호를 안써도 된다.
단, 상속을 받지 않아도 괄호를 써도 된다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">a_cat</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">another_cat</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">()</span>
</span></span></code></pre><p>함수처럼 클래스 이름(변수)을 호출하여 클래스로부터 객체를 생성할 수 있다.</p>
<p><strong>Cat()은 Cat 클래스로부터 개별 객체를 생성한다</strong>. =&gt; 매번 <code>Cat()</code>을 호출할 때마다, 파이썬은 이전에 생성된 객체와는 완전히 독립적인 새로운 객체를 만들어낸다. 즉,  a_cat과 another_cat 객체는 서로 다른 별개의 객체이다.
그리고 이런 개체를 a_cat과 another_cat 변수에 할당한다.
그러나, Cat 클래스는 빈 클래스이기 때문에 생성한 객체만 존재할 뿐 아무것도 할 수 없다.</p>
<h2>속성</h2>
<p><strong>속성(attribute)은 클래스나 객체 내부의 변수다.</strong>
속성을 이야기할 때, 일반적으로 객체의 속성을 의미한다.
단, 클래스 속성도 존재햔다.</p>
<p>객체 or 클래스가 생성되는 동안이나, 나중에 생성한 후에도 속성을 할당할 수 있다.
<strong>즉, 객체가 생성된 후에도, 생성되기 전에도 해당 객체에 속성을 자유롭게 할당하여 추가할 수 있다. 클래스도 속성을 추가할 수 있다.</strong>
왜냐면, 이는 Python 객체가 자신의 속성을 (일반적으로) <code>__dict__</code>라는 <strong>딕셔너리 형태의 가변적인 이름 공간에 저장</strong>하기 때문에 가능하다. =&gt; 거의 객체의 가변성과 유사한 것이다.
객체를 불변하게 한다는 것은 속성을 추가하지도, 변경하지도 못하게 한다는 거다. =&gt; Python에는 사용자 정의 클래스의 객체를 &quot;완전히&quot; 그리고 &quot;강제적으로&quot; 불변하게 만드는 단일 키워드나 직접적인 메커니즘이 C++의 <code>const</code>처럼 명확하게 존재하지는 않습니다. =&gt; @dataclasses.dataclass(frozen=True) 데커레이터를 사용하는 것을 권장합니다.</p>
<p>Q: 객체 내부의 변수를 어떻게 할 당이 가능한건가? 객체가 가변이라 그런가? 아니, 불변도 있을거 아닌가??</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cat</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a_cat</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a_cat</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Cat</span> <span class="nb">object</span> <span class="n">at</span> <span class="mi">0</span><span class="n">x</span><span class="o">...&gt;</span>
</span></span></code></pre><p>객체 변수 자체를 출력하면 함수 변수 자체를 출력한 결과와 똑같이 <code>__repr__()</code> 를 호출한 결과가 출력된다.
이러한 이유는, 기본 동작으로 자체적으로 프로그래밍 되어 있는 것이다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cat</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">pass</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="n">a_cat</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">another_cat</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a_cat</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">a_cat</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&#34;Mr. F&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">a_cat</span><span class="o">.</span><span class="n">nemesis</span> <span class="o">=</span> <span class="n">another_cat</span>
</span></span></code></pre><p>객체에 속성을 3개 할당해보자.
객체에 점 표기법을 활용하여 속성을 할당할 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">a_cat</span><span class="o">.</span><span class="n">age</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a_cat</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Mr. F&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a_cat</span><span class="o">.</span><span class="n">nemesis</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Cat</span> <span class="nb">object</span> <span class="n">at</span> <span class="mi">0</span><span class="n">x</span><span class="o">...&gt;</span>
</span></span></code></pre><p>할당한 속성에 접근이 가능하다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">a_cat</span><span class="o">.</span><span class="n">nemsis</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span></code></pre><p>nemsis 속성은 다른 Cat 객체를 참조한다.
another_cat 객체는 age, name, nemesis 속성을 할당하지 않았으므로 에러가 발생한다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">a_cat</span><span class="o">.</span><span class="n">nemesis</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&#34;Mr. F&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">a_cat</span><span class="o">.</span><span class="n">nemesis</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;Mr. F&#34;</span>
</span></span></code></pre><p>nemesis에 할당된 객체에 속성을 할당할 수도 있다.</p>
<p>이와 같이 객체를 여러 속성을 저장하는데 사용할 수 있다.
즉, 다른 자료구조를 사용하는 대신 여러 객체를 사용하여 다른 값을 저장할 수 있다.</p>
<h2>메서드</h2>
<p>메서드(method)는 클래스 또는 객체의 함수다.
메서드는 함수와 비슷하다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Car</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">exclaim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I&#39;m a Car!&#34;</span><span class="p">)</span>
</span></span></code></pre><p>클래스 내부에서 메서드를 선언할 수 있다.
대부분의 경우, &quot;메서드를 만든다&quot;고 하면 클래스 정의 내부에 <code>def</code>를 사용하여 만드는 것을 의미한다.</p>
<p><strong>메서드를 만들때는 항상 첫 번째 인자 self가 필요하다.</strong></p>
<p>Q: 객체에서 메서드를 할당하는 방법은 무엇인가?</p>
<h2>객체 초기화 메서드:  <code>__init__()</code></h2>
<p><strong>객체를 생성할 때(인스턴스에) 속성을 할당하려면 객체 초기화 메서드 <code>__init__()</code> 을 사용한다.</strong>
<strong><code>__init__()</code> 은 클래스 정의에서 선언하여, 개별 객체를 초기화하는 특수 메서드다.</strong>
객체 초기화 메서드는 클래스를 생성할 때(정의할 때) 속성을 할당하는 것이 아니다.
클래스를 호출하여 객체를 생성할 때, 그 생성한 객체(인스턴스)에 다가 속성을 할당하는 것이 객체 초기화 메서드다.
단, 클래스를 생성할때(정의할때) 속성을 할당하는 방법도 있다. 이를 클래스 속성이라고 한다.
객체 초기화 메서드를 활용하면 굳이 점 표기법으로 속성을 객체에 할당하지 않아도 된다.
단순히 객체를 만들고 나서 수동으로 속성을 할당하는 것보다, 객체 초기화 메서드를 사용하는 것이 훨씬 체계적이고 안전하며 편리한 방법이다.</p>
<p>모든 클래스 정의에서 <code>__init__()</code> 메서드를 가질 필요는 없다.
<code>__init__()</code> 메서드는 같은 클래스에서 생성된 다른 객체를 구분하기 위해 필요한 다른 뭔가를 수행하낟.
<code>__init__()</code> 메서드는 다른 언어에서 부르는 생성자의 개념이 아니다.
<code>__init__()</code> 메서드 호출 전에 이미 객체를 클래스 호출로부터 생성했기 때문이다.
<code>__init__()</code>  메서드는 인스턴스에 속성을 초기화하는 메서드(초기화 메서드)라고 생각해야 한다.</p>
<h2>객체 초기화 메서드: self 매개변수</h2>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cat</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">pass</span>
</span></span></code></pre><p><strong>클래스 정의에서 <code>__init__()</code> 을 정의할 때, 무조건 첫 번째 매개변수는 개별 객체 자신을 참조하는 매개변수다.</strong>
여기서 <code>__init__()</code> 내부의 <code>self</code> 매개변수는 클래스 호출로 부터 생성된 <strong>개별 객체 자신</strong>을 참조하도록 지정하는 역할을 한다.
주의할 점은, 무조건 첫 번째 매개변수(self)를 지정해야 한다.</p>
<ul>
<li>이유:
<ul>
<li><strong>Python의 메서드 호출 메커니즘상, 메서드를 호출한 인스턴스가 해당 메서드에 첫 번째 인자로 자동 전달됩니다.</strong></li>
<li><strong>메서드 정의는 이 자동으로 전달되는 인스턴스를 받기 위한 매개변수를 가지고 있어야 합니다.</strong></li>
<li>이를 통해 메서드는 자신이 어떤 인스턴스에 대해 작동해야 하는지 알고, 해당 인스턴스의 속성과 다른 메서드에 접근할 수 있습니다.</li>
<li>솔직히 잘 모르겠다. 그냥 self 쓰자.
개별 객체 자신을 참조하는 첫 번째 매개변수의 이름은 일반적으로 self를 사용하고, 권장한다.
그러나, 주의할 점은 self 이름이 예약어는 아니다. 다른 것으로 사용해도 에러가 나지 않는다.</li>
</ul>
</li>
</ul>
<h2>객체 초기화 메서드: 동적 속성</h2>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cat</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">furball</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">(</span><span class="s1">&#39;Grumpy&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">furball</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Grumpy&#39;</span>
</span></span></code></pre><p>클래스 호출시 인자를 제공하면 객체 초기화 메서드 <code>__init__</code> 의 매개변수에 인자를 제공할 수 있다.
즉, 여기서 Cat()은 호출할 때 name 인자를 받아야 하고, 이 name 인자는 init 함수의 name 매개변수로부터 전달되어 객체를 생성한 후 name 이라는 속성에 전달받은 name 매개변수 값이 할당되게 된다.
그러면 이렇게 동적으로 값을 받아서 인스턴스에 속성을 초기화할 수 있다.</p>
<p><strong><code>__init__</code> 메서드 내에서 <code>self.name = name</code>과 같이 속성을 할당하는 것은, 객체가 생성된 후에 <code>furball.age = 5</code>와 같이 속성을 추가하거나 할당하는 것과 근본적인 메커니즘 면에서는 결이 같다.</strong>
<strong>즉, self.name 은 furball.name 과 느낌이 비슷하다.</strong></p>
<p>하나의 클래스에서 많은 객체를 개별적으로 만들 수 있다. =&gt; 이 말은 하나의 클래스를 가지고 여러 개의 서로 다른 인스턴스를 만들 수 있다는 뜻이다.
그러나, 파이썬은 데이터를 객체로 구현하므로 클래스 자체가 객체다. =&gt; 클래스(예: <code>Cat</code>) 자체도 하나의 객체로 취급된다.
프로그램에서는 한 클래스 객체만 있다. =&gt; <code>class Cat(): ...</code>과 같이 클래스를 한 번 정의하면, 해당 프로그램 내에서 그 클래스 객체 <code>Cat</code>은 유일하게 하나만 존재한다. =&gt; <code>Cat()</code>을 여러 번 호출해서 여러 인스턴스를 만들더라도, 그 인스턴스들의 &quot;설계도&quot; 역할을 하는 클래스 객체 <code>Cat</code> 자체는 여전히 하나이다. =&gt; 이것은 <code>Cat</code> 클래스의 <em>인스턴스</em>(예: <code>furball</code>)를 하나만 만들 수 있다는 뜻이 절대 아니다.
위 예제처럼 Cat 클래스를 정의했다면, 프로그램에서 이 클래스의 객체 하나만 존재한다. =&gt; 위 문장과 동일한 뜻이다.</p>
<p>더불어, <code>__init__</code> 메서드(또는 클래스를 호출하여 객체를 생성할 때 전달되는 다른 특별 메서드들)에게 인자를 제공할 때 <strong>키워드 인자(keyword arguments)를 사용할 수 있다.</strong> 위치 인수(positional arguments)만 사용해야 하는 것은 아니다.</p>
<h2>상속</h2>
<p>상속(inherit)은 기존 클래스에서 일부를 추가하거나 변경하여 새 클래스를 생성하는 것을 의미한다.
코드를 재사용하는 좋은 방법이다.
상속을 이용하면 새로운 클래스는 기존 클래스를 복사하지 않고 기존 클래스의 모든 코드를 사용할 수 있다.
필요한 것만 추가하거나 변경해서 새 클래스를 정의한다. 그리고 기존 클래스의 행동(behavior)을 재정의(override)한다.</p>
<p><strong>자식 클래스는 부모 클래스로부터 모든 것을 상속받는다.</strong>
<strong>즉, 상속받는다는 것은 부모 클래스의 자원(속성, 메서드, 등등)을 다 사용할 수 있다는 거다. 더불어 override 또한 가능하다.</strong></p>
<p>기존 클래스는 부모(parent), 슈퍼(super), 베이스(base) 클래스, 제네릭(generic) 클래스라고 부른다.
새 클래스는 자식(child), 서브(sub), 파생된(derived) 클래스라고 부른다.
이 용어들은 객체 지향 프로그래밍(Object-Oriented Programming(OOP))에서 사용된다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Car</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Yugo</span><span class="p">(</span><span class="n">Car</span><span class="p">):</span> <span class="c1"># 상속</span>
</span></span><span class="line"><span class="cl">	<span class="k">pass</span>
</span></span></code></pre><p>상속은 class 키워드를 사용하고, 괄호 안에 부모 클래스의 이름을 지정하여 서브 클래스를 선언할 수 있다.
그리고 괄호 안에는 여러 클래스 이름을 지정하여 다중 상속을 진행할 수도 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="nb">issubclass</span><span class="p">(</span><span class="n">Yugo</span><span class="p">,</span> <span class="n">Car</span><span class="p">)</span>
</span></span></code></pre><p>issubclass() 함수를 사용하여 첫 번째 인자로 받은 클래스가 두 번째 인자로 받은 클래스로부터 파생되었는지 확인할 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">give_me_a_car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_yugo</span> <span class="o">=</span> <span class="n">Yugo</span><span class="p">()</span>
</span></span></code></pre><p>이렇게 클래스로부터 객체(인스턴스)를 생성할 수 있다.</p>
<p>자식 클래스는 부모 클래스를 구체화(specialization)한 것이다.
객체 지향 용어로 말하자면, Yugo는 Car다(<strong>Yugo is-a Car</strong>)
give_me_a_yugo 객체는 Yugo 클래스의 인스턴스이고, Car 클래스가 할 수 있는 것을 상속받는다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Car</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">exclaim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I&#39;m a Car!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Yugo</span><span class="p">(</span><span class="n">Car</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_yugo</span> <span class="o">=</span> <span class="n">Yugo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_car</span><span class="o">.</span><span class="n">exclaim</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">I</span><span class="s1">&#39;m a Car!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_yugo</span><span class="o">.</span><span class="n">exclaim</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">I</span><span class="s1">&#39;m a Car!</span>
</span></span></code></pre><p>Yugo는 Car로부터 exclaim() 메서드를 상속받았다.</p>
<p>상속은 충분히 매력적이지만 남용될 수 있다.
상속을 너무 많이 사용하면 프로그램을 관리하기 어렵다.
대신 애그리게이션(aggregation), 콤퍼지션(composition)과 같은 기술을 사용하는 것이 더욱 좋을 수도 있다.</p>
<p>Q: 속성 상속은 어떻게 하고, 속성 상속은 어떻게 오버라이드 하나?</p>
<h2>메서드 오버라이드</h2>
<p>자식 클래스는 부모 클래스로부터 모든 것을 상속받는다.
좀더 나아가서, 부모 메서드를 어떻게 오버라이드(대체)하는지 살펴볼 것이다.</p>
<p>Yugo 클래스는 어떤 식으로든 Car 클래스와 달라야 한다. 그렇지 않으면 새로운 클래스를 정의하는 것이 무슨 의미가 있겠는가?</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Car</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">exclaim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I&#39;m a Car!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Yugo</span><span class="p">(</span><span class="n">Car</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">exclaim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I&#39;m a Yugo! Much like a CAr, but more Yugo-ish.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_yugo</span> <span class="o">=</span> <span class="n">Yugo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_car</span><span class="o">.</span><span class="n">exclaim</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">I</span><span class="s1">&#39;m a Car!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_yugo</span><span class="o">.</span><span class="n">exclaim</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">I</span><span class="s1">&#39;m a Yugo! Much like a CAr, but more Yugo-ish.</span>
</span></span></code></pre><p>Yugo 클래스에서 exclaim 메서드를 오버라이드했다.
파이썬에서는 <code>__init__()</code> 메서드를 포함한 모든 메서드를 오버라이드할 수 있다.
메서드를 오버라이드하려면 부모 클래스에서 사용된 것과 동일한 이름(변수)을 자식 클래스에서 사용해야 한다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MDPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&#34;Doctor &#34;</span> <span class="o">+</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">JDPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&#34; , Esquire&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">person</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s2">&#34;Fudd&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">doctor</span> <span class="o">=</span> <span class="n">MDPerson</span><span class="p">(</span><span class="s2">&#34;Fudd&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">lawyer</span> <span class="o">=</span> <span class="n">JDPerson</span><span class="p">(</span><span class="s2">&#34;Fudd&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">person</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">doctor</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">lawyer</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></span></code></pre><p>이러한 경우 초기화 메서드는 부모 클래스의 person과 같은 인수를 취하지만, 객체의 인스턴스 내부에서는 다른 name 값을 저장한다. =&gt; 이 말은 자식 클래스들(<code>MDPerson</code>, <code>JDPerson</code>)의 <code>__init__</code> 메서드가 <strong>호출될 때 받는 인수의 형태(개수, 이름 등)가 부모 클래스 <code>Person</code>의 <code>__init__</code> 메서드가 받는 인수의 형태와 동일하다</strong>는 뜻이다. 즉, 인수의 형태가 뭐 동일하다 이런 의미다. 즉, self, name을 동일하게 받지만, 처리는 다르다는 뜻이다. 왜냐면 mdperson은 상속을 받았어도 init을 재작성을 했기에 다르게 작동할 수 밖에 없다. mdperson 클래스에게 인수를 전달한 것은 person 클래스의 init 메서드의 매개변수에게 가지 않는다. 재작성한 mdperson의 init 메서드의 매개변수로 전달된다.</p>
<h2>메서드 추가하기</h2>
<p>자식 클래스에서 부모 클래스에 없는 메서드를 추가할 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Car</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">exclaim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I&#39;m a Car!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Yugo</span><span class="p">(</span><span class="n">Car</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">exclaim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I&#39;m a Yugo! Much like a Car, but more Yugo-ish.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">need_a_push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A little help here?&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_yugo</span> <span class="o">=</span> <span class="n">Yugo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_yugo</span><span class="o">.</span><span class="n">need_a_push</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">little</span> <span class="n">help</span> <span class="n">here</span><span class="err">?</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">give_me_a_car</span><span class="o">.</span><span class="n">need_a_push</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="o">...</span>
</span></span></code></pre><p>Yugo 클래스에만 있는 새로운 메서드를 정의할 수 있다.
Yugo는 Car가 못하는 뭔가를 할 수 있고, 독특한 개성을 나타낼 수 있다.</p>
<h2>부모에게 도움받기: super()</h2>
<p>지금까지 자식 클래스에서 메서드를 추가하거나, 부모 클래스로부터 메서드를 오버라이드하는 방법을 살펴봤다.</p>
<p>자식 클래스에서 부모 클래스를 호출하고 싶다면 어떻게 할끼? super() 메서드를 사용하면 된다.
super() 로 부모 클래스 내부에 존재하는 메서드를 자식 클래스에 가져와서 호출할 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">EmailPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">email</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bob</span> <span class="o">=</span> <span class="n">EmailPerson</span><span class="p">(</span><span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;bob@bob.bob&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bob</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Bob&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bob</span><span class="o">.</span><span class="n">email</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;bob@bob.bob&#39;</span>
</span></span></code></pre><p>자식 클래스에서 <strong>init</strong>() 메서드를 정의하면 이는 부모 클래스의 <strong>init</strong>() 메서드를 대체(오버라이드)하는 것이기 때문에 더 이상 자동으로 부모 클래스의 <strong>init</strong>() 메서드가 호출되지 않는다. 그러므로, 이것을 명시적으로 호출해야 한다.</p>
<p>super() 메서드는 부모 클래스의 정의를 얻는다.
super().<strong>init</strong>() 메서드는 Person.<strong>init</strong>() 메서드를 호출한다. 이 메서드는 self 인수를 슈퍼 클래스로 전달하는 역할을 한다. 그러므로 슈퍼 클래스에서 선택적 인수를 제공하기만 하면 된다. 이 경우 Person() 에서 받는 인수는 name이다. =&gt; <strong>부모 클래스 <code>__init__</code> 메서드의 시그니처(필수 매개변수)를 반드시 만족해야 합니다.</strong></p>
<ul>
<li>일반적인 함수 호출과 마찬가지로, <code>super().__init__(...)</code>를 통해 부모 클래스의 <code>__init__</code>을 호출할 때도 해당 메서드가 <strong>요구하는 모든 필수 매개변수에 대한 인수를 전달해야 합니다.</strong></li>
<li>만약 부모 클래스의 <code>__init__</code> 메서드에 기본값이 없는 필수 매개변수가 있는데 이를 <code>super().__init__(...)</code> 호출 시 전달하지 않으면 <code>TypeError</code>가 발생합니다.
<strong>즉, super() 로 부모 클래스 내부에 존재하는 메서드를 호출할 수 있다. 단, init 메서드를 호출하려면 필수 인자를 모두 만족해야 한다.</strong>
self.email = email 은 EmailPerson 클래스를 Person 클래스와 다르게 만들어주는 새로운 코드다.</li>
</ul>
<p>그러면 왜 자식 클래스에서 다음과 같이 <code>self.name = name</code> 으로 정의하지 않았을까?</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">EmailPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">email</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span>
</span></span></code></pre><p>위와 같이 정의할 수도 있지만, 이것은 상속의 이점을 활용할 수 없다.
위에서 super() 메서드를 활용하여 Person 클래스에서 일반 Person 객체와 같은 방식으로 EmailPerson 클래스에서 속성을 초기화하도록 동작하게 만들었다.</p>
<p>super() 메서드에 대한 또 다른 이점이 있다.
Person 클래스 정의가 나중에 바뀌면 Person 클래스로부터 상속받은 EmailPerson 클래스의 속성과 메서드에 변경 사항이 변경된다는 것이다.
매우 효율적이다.</p>
<p>즉, 현실의 부모와 자식의 관계처럼, 자식 클래스가 자신의 방식으로 무언가를 처리하지만, 여전히 부모 클래스로부터 무언가가 필요할 때 super() 메서드를 사용한다.</p>
<h2>다중 상속</h2>
<p>클래스는 여러 부모 클래스를 상속받을 수 있다.
괄호에 2개 이상 클래스 이름을 기입하여 다중 상속을 할 수 있다.</p>
<p>클래스가 가지고 있지 않은 메서드 또는 속성을 참조하게 되면, 파이썬은 모든 부모 클래스를 조사한다.
웃기지만, 이건 정말로 가능하다. 그리고 이것이 바로 상속(inheritance)의 가장 강력하고 핵심적인 기능 중 하나이다.</p>
<p>파이썬의 상속은 메서드 해석 순서(MRO)에 달려있다.
각 파이썬 클래스에는 특수 메서드 mro()가 있다. =&gt; <strong>리스트(list)를 반환합니다</strong>: 이 메서드를 호출하면, 해당 클래스에서 어떤 메서드나 속성을 찾을 때 Python이 탐색하는 클래스들의 순서를 담은 <strong>리스트</strong>가 반환됩니다.
mro() 메서드는 해당 클래스 객체에 대한 메서드 또는 속성을 찾는 데 필요한 클래스의 리스트를 반환한다.
<strong>mro</strong> 라는 유사한 속성은 해당 클래스의 튜플이다. =&gt; <code>__mro__</code> 튜플이 실제로 Python 인터프리터가 메서드나 속성을 찾을 때 사용하는 MRO 정보입니다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Animal</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">says</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s1">&#39;I speak!&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Horse</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">says</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s1">&#39;Neigh!&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Donkey</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">says</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s1">&#39;Hee-haw!&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Mule</span><span class="p">(</span><span class="n">Donkey</span><span class="p">,</span> <span class="n">Horse</span><span class="p">):</span> <span class="c1"># 다중 상속</span>
</span></span><span class="line"><span class="cl">	<span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Hinny</span><span class="p">(</span><span class="n">Horse</span><span class="p">,</span> <span class="n">Donkey</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Mule</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">Hinny</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">mule</span> <span class="o">=</span> <span class="n">Mule</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">hinny</span> <span class="o">=</span> <span class="n">Hinny</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">mule</span><span class="o">.</span><span class="n">says</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;hee-haw!&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">hinny</span><span class="o">.</span><span class="n">says</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Neigh!&#39;</span>
</span></span></code></pre><p>Mule 클래스가 says 메서드를 가지지 않으니, MRO에 따라 Donkey 클래스를 먼저 참조하고, 이에 정의된 says 메서드를 실행한 결과를 반환한다.</p>
<p>Horse, Donkey 클래스에서 says() 메서드를 가지고 있지 않다면 mule 이나 hinny 객체는 부모의 부모인 Animal 클래스를 사용하여 I speak! 를 반환한다.</p>
<h2>믹스인</h2>
<p>pass</p>
<h2>자신: self</h2>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Car</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">exclaim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I&#39;m a Car!&#34;</span><span class="p">)</span>
</span></span></code></pre><p>에서</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">a_car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">a_car</span><span class="o">.</span><span class="n">exclaim</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">I</span><span class="s1">&#39;m a Car!</span>
</span></span></code></pre><p>와</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">a_car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">Car</span><span class="o">.</span><span class="n">exclaim</span><span class="p">(</span><span class="n">a_car</span><span class="p">)</span>
</span></span></code></pre><p>는 똑같은 역할을 하는 코드다.</p>
<ul>
<li>a_car 객체의 Car 클래스를 찾는다</li>
<li>a_car 객체를 Car 클래스 exclaim() 메서드의 self 매개변수에 전달한다.</li>
</ul>
<p>a_car.exclaim() 은 Car.exclaim(a_car)와 같다.<br>
즉, 파이썬은 <code>클래스 이름.메서드(클래스의 인스턴스)</code> 이렇게 모든 메서드가 동작하게 된다.<br>
이것이 바로 Python이 내부적으로 인스턴스 메서드 호출을 처리하는 방식입니다. 우리가 <code>인스턴스.메서드()</code> 형태로 코드를 작성하면, Python은 사실상 그 인스턴스의 클래스로부터 해당 메서드(정확히는 함수)를 찾은 다음, 그 메서드의 첫 번째 인자(<code>self</code>)로 해당 인스턴스를 자동으로 넘겨주어 호출합니다.</p>
<p><strong>나는 신기한게, 클래스.메서드 이렇게 접근이 가능하다는 건가?</strong><br>
<code>Car.exclaim</code>과 같이 클래스를 통해 가져온 메서드(함수 객체)는 첫 번째 인자로 해당 클래스의 인스턴스를 기대합니다 (이것이 <code>def exclaim(self):</code> 에서의 <code>self</code>입니다).<br>
이것이 <code>a_car.exclaim()</code>과 동일하게 동작하는 이유입니다. <code>a_car.exclaim()</code>은 Python이 내부적으로 <code>Car.exclaim(a_car)</code> 형태로 변환하여 처리해주는 &quot;편리한 문법(syntactic sugar)&quot;이라고 볼 수 있습니다.</p>
<ul>
<li><strong>클래스 내에 정의된 메서드는 해당 클래스 객체의 속성입니다 (<code>Car.exclaim</code>).</strong></li>
<li><strong>이 속성(함수 객체)에 접근할 수 있습니다.</strong></li>
<li><strong>이 함수 객체를 직접 호출하면서 첫 번째 인자로 해당 클래스의 인스턴스를 전달하면 (<code>Car.exclaim(a_car)</code>), 인스턴스 메서드가 정상적으로 실행됩니다. 이는 <code>a_car.exclaim()</code>과 동일한 효과를 냅니다.</strong><br>
<strong>그래서 클래스는 객체(속성...)를 반환한다는 말이다. 이렇게 동작할 수 있기 때문에.</strong></li>
</ul>
<p>즉, 내가 신기한 것은 클래스 이름을 직접적으로 활용해서 객체를 사용할 수도 있다는 사실이다. 즉, 인스턴스가 아닌, 클래스 자체로 어떤 것을 할 수 있을끼?</p>
<p>아. 클래스는 그 클래스 자체로 사용이 가능하다는 거다.<br>
즉, class Car() 이렇게 정의하면 이 클래스 자체적으로 활용가능 한건데, 이 클래스로부터 생성된 객체를 생성한 것을 인자로 전달해야 한다는 거다. 그래서 객체를 클래스로부터 생성해야 한다는 거다. 와 미쳤다. 즉, 클래스 자체적으로 활용한다는 거다. Car.exclaim(a_car) 이렇게 말이다.<br>
그리고 a_car = Car() 도 사실상, a_car = Car.<strong>new</strong>(...) + Car.<strong>init</strong>(...)의 축약이다.</p>
<p>=&gt; class Car(): ... 이렇게 정의된 Car 클래스는 그 자체로 하나의 객체이며, Car.exclaim(a_car)처럼 클래스 이름을 통해 직접 메서드를 호출할 수 있습니다<br>
=&gt; 네, 클래스는 그 자체로 메서드를 가지고 있으며, ClassName.method(instance, args) 형태로 호출할 수 있습니다. 이것이 메서드의 근본적인 형태입니다.<br>
=&gt; 즉, class ... 이렇게 클래스 자체를 정의한 것도, 클래스는 그 자체로 객체 임으로 클래스 이름으로 접근하여 활용이 가능하다. 그리고 많은 경우 클래스 이름으로 접근해서 활용한다. 그러나, 편의상 이렇게 많이는 하지 않는다.</p>
<p>그래서, **클래스 속성(class attribute)<strong>은 클래스 자체를 통해 직접 접근하고 활용할 수 있다.</strong><br>
=&gt; 미쳤다.<br>
<strong>즉, 클래스 그 정의한 것 자체도 그냥 객체다. 뭐 다르게 접근해서 하는 게 아니다. 그냥 값을 가져올 수 있는 하나의 객체 덩어리다! 그냥 클래스 이름 그 자체로 접근할 수 있다!!!!!</strong></p>
<blockquote>
<p>혼란할 수 있다. 익숙해져야 한다.</p>
</blockquote>
<h2>속성 접근</h2>
<p>파이썬은 일반적으로 객체 속성과 메서드는 공개되어 있기에, 이를 개발자가 스스로 잘 관리해야 한다. 이를 동의 성인 정책이라고 부른다.
이번 절에서는 직접 접근 방식과 일부 대안을 살펴본다.</p>
<h2>직접 접근</h2>
<p>객체(클래스(다시 한 번 말한다. 클래스 또한 그냥 객체 덩어리다.))의 속성 값을 직접 가져와서 설정할 수 있다.
<code>객체.속성</code> 이렇게 점 표기법으로 속성 값을 직접 가져올 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Duck</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">input_name</span>
</span></span><span class="line"><span class="cl"><span class="n">fowl</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="s1">&#39;Daffy&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">fowl</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Daffy&#39;</span>
</span></span></code></pre><p>이렇게 속성을 수정할 수도 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">fowl</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Daphne&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">fowl</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Daphne&#39;</span>
</span></span></code></pre><p>단, <strong>이것은 객체의 속성이 새로운 객체를 참조하도록 변경한 것이다.</strong>
조금 다르지만, 속성 자체를 수정한 게 아니다.
속성이 참조하는 객체를 바꾼 거다.</p>
<p><strong>파이썬에서는 이미 존재하는 객체의 속성을 수정할 수 있다.</strong>
<strong>파이썬에서는 이미 존재하는 객체에 새로운 속성을 동적으로 할당할 수 있다.</strong></p>
<p>다음 두 절에서는 실수로 어떤 개발자가 위 예제와 같이 수정하지 못하도록 속성에 대한 접근 프라이버시를 얻는 방법을 살펴보자.</p>
<h2>Getter/Setter 메서드</h2>
<p>객체 지향 언어에서는 외부로부터 바로 접근할 수 없는 private 객체 속성을 지원한다.
파이썬 개발자는 private 속성의 값을 읽고 쓰기 위해 getter/setter 메서드를 사용한다.</p>
<p>파이썬에는 private 속성이 없다. 그러나 조금의 프라이버시를 얻기 위해 getter/setter 메서드를 사용할 수 있다.
그러나, getter/setter 보다 가장 좋은 해결책은 프로퍼티를 사용하는 것이다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Duck</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">hidden_name</span> <span class="o">=</span> <span class="n">input_name</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside the getter&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_name</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside the setter&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">hidden_name</span> <span class="o">=</span> <span class="n">input_name</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">don</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="s1">&#39;donald&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;donald&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;a&#39;</span>
</span></span></code></pre><p>여기 self.hidden_name에서 이 self는 class로부터 생성된 객체고, 이 self는 모두 같은 객체를 가리키는 것이 맞나? 즉, self.hidden_name이 <strong>init</strong>, get_name, set_name에서 쓰였는데, 여기서 사용된 self는 class로부터 생성된 인스턴스를 모두 같은 인스턴스를 참조하는 건가?
<strong>맞다. <code>Duck</code> 클래스의 <code>__init__</code>, <code>get_name</code>, <code>set_name</code> 메서드 내에서 사용된 <code>self</code>는 모두 동일한 객체 인스턴스를 가리킨다. 그래서 self.hidden_name이 모든 메서드에서 사용될 수 있는 것이다.</strong></p>
<blockquote>
<p>혼란할 수 있다. 익숙해지자.</p>
</blockquote>
<p>단 이 방법도 hidden_name 속성을 직접 참조를 할 수 있긴 하다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="c1"># 외부에서 hidden_name에 직접 접근</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">don</span><span class="o">.</span><span class="n">hidden_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 외부에서 hidden_name을 직접 변경</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">hidden_name</span> <span class="o">=</span> <span class="s1">&#39;Daisy&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">don</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Daisy&#39;</span>
</span></span></code></pre><h2>속성 접근을 위한 프로퍼티</h2>
<p>속성 프라이버시를 위한 파이써닉한 방법은 프로퍼티(property)를 사용하는 것이다.</p>
<p><strong>프로퍼티(<code>property</code>)는 getter와 setter 메서드를 일반적인 속성(attribute)처럼 편리하게 접근하고 사용할 수 있도록 해주는 기능이다.</strong></p>
<p>두 방법으로 프로퍼티를 사용할 수 있다.</p>
<h2>property() 함수</h2>
<p>첫 번째 방법은 property() 함수를 활용하는 것이다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Duck</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">hidden_name</span> <span class="o">=</span> <span class="n">input_name</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside the getter&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_name</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside the setter&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">hidden_name</span> <span class="o">=</span> <span class="n">input_name</span>
</span></span><span class="line"><span class="cl">	<span class="n">name</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_name</span><span class="p">,</span> <span class="n">set_name</span><span class="p">)</span>
</span></span></code></pre><p>이렇게 <code>name = property(...)</code> 를 클래스 정의 맨 마지막 줄에 추가하여 프로퍼티를 사용할 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">don</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="s1">&#39;donald&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;donald&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;a&#39;</span>
</span></span></code></pre><p>property를 추가했어도, getter/setter 메서드는 여전히 잘 동작한다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">don</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="s1">&#39;donald&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;donald&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;a&#39;</span>
</span></span></code></pre><p>그러나, property로 할당한 속성 이름 name 을 활용하여 hidden_name 속성을 가져오거나(getter), 설정할 수 있다(setter).</p>
<p>위에서 볼 수 있듯이, 프로퍼티는 getter/setter를 특정 속성 이름으로 편리하게 접근하게 하는 것이다.</p>
<h2>@property 데커레이터</h2>
<p>두 번째 방법은 @property 데커레이터를 활용하는 것이다.</p>
<ol>
<li>두 메서드 이름(get_name, set_name)을 name으로 바꾼다.</li>
<li>getter 메서드 앞에 @property 데커레이터를 쓴다.</li>
<li>setter 메서드 앞에 @name.setter 데커레이터를 쓴다.</li>
</ol>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Duck</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">hidden_name</span> <span class="o">=</span> <span class="n">input_name</span>
</span></span><span class="line"><span class="cl">	<span class="nd">@property</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside the getter&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_name</span>
</span></span><span class="line"><span class="cl">	<span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside the setter&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">hidden_name</span> <span class="o">=</span> <span class="n">input_name</span>
</span></span></code></pre><p><code>@property</code>는 데코레이터입니다. 이 데코레이터가 <code>def name(self): ...</code> 메서드 위에 사용되면, 이 <code>name</code> 메서드는 <code>name</code>이라는 이름의 프로퍼티(property)에 대한 <strong>getter 메서드</strong>가 됩니다.</p>
<p><code>@name.setter</code>는 이 <code>name</code> 프로퍼티 객체의 <code>setter</code> 메서드를 사용하여, 그 아래에 정의된 메서드(여기서는 두 번째 <code>def name(self, input_name): ...</code>)를 해당 프로퍼티의 <strong>setter 메서드</strong>로 등록합니다.</p>
<p><code>@property</code>는 &quot;이 메서드를 getter로 하는 프로퍼티를 만들고, 그 프로퍼티의 이름을 이 메서드 이름으로 하겠다&quot;라는 선언과 같습니다. 이것이 프로퍼티를 정의하는 가장 첫 단계입니다.</p>
<p>근데 @name.getter라고 안쓰고 왜 @property 라고 쓰는가? 왜 @property는 getter를 수반하는가?
=&gt; 아 그렇지! 위에서도</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">don</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="s1">&#39;donald&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">don</span><span class="o">.</span><span class="n">name</span>
</span></span></code></pre><p>이렇게 don.name 하면 getter가 되었으니까!
프로퍼티 선언이 곧 getter를 함의하는 것이네!!!!!
미쳤다.</p>
<p>이렇게 @property를 사용하면, property() 함수와 똑같이 속성처럼 name에 접근할 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">fowl</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="s1">&#39;howard&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">fowl</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">fowl</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span></code></pre><p><strong>하지만 다시 한 번 말하지만, fowl.hidden_name 으로 이 속성을 바로 읽고-수정할 수 있다. 속성 이름은 완전히 숨길 수는 없는 것이다. 그러나, 속성 이름을 약간 숨길 수 있는 방법이 있다. (<code>__</code>를 사용하는 것이다.)</strong></p>
<h2>계산된 값의 프로퍼티</h2>
<p>프로퍼티는 계산된 값(computed value)을 참조할 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
</span></span><span class="line"><span class="cl">	<span class="nd">@property</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">radius</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">diameter</span>
</span></span><span class="line"><span class="cl"><span class="mi">10</span>
</span></span></code></pre><p>단, 일반 메서드도 계산된 값을 반환할 수 있긴 하다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">get_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># 일반 메서드</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_circle</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">diameter_val</span> <span class="o">=</span> <span class="n">my_circle</span><span class="o">.</span><span class="n">get_diameter</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">diameter_val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">20</span>
</span></span></code></pre><p>단, 일반 속성도 계산된 값을 반환할 수 있긴 하다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># &#39;diameter_attribute&#39;는 __init__ 시점에 계산된 값을 저장하는 일반 속성입니다.</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">diameter_attribute</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 사용 예시</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 일반 속성 접근</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;일반 속성 diameter_attribute: </span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">diameter_attribute</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>  <span class="c1"># 출력: 일반 속성 diameter_attribute: 10</span>
</span></span></code></pre><p>radius 속성은 언제든지 바꿀 수 있다. 그리고 diameter 프로퍼티는 오직 현재의 radius 값으로부터 계산되어 반환한다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
</span></span><span class="line"><span class="cl">	<span class="nd">@property</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">diameter</span>
</span></span><span class="line"><span class="cl"><span class="mi">14</span>
</span></span></code></pre><blockquote>
<p>다시 재고할 점, 속성은 추가-변경이 가능하다.</p>
</blockquote>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">diameter</span> <span class="o">=</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span><span class="o">...</span>
</span></span></code></pre><p>단, @property는 getter이기에 이렇게 하면 에러가 난다.
@diameter.setter 라는 setter를 추가해야 한다.</p>
<h2>프라이버시를 위한 네임 맹글링</h2>
<p>파이썬은 클래스 정의 외부에서 볼 수 없도록 하는 속성에 대한 네이밍 컨벤션이 있다.
속성 이름 앞에 두 언더바(<code>__</code>)를 붙이면 된다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Duck</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">input_name</span>
</span></span><span class="line"><span class="cl">	<span class="nd">@property</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside the getter&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>
</span></span><span class="line"><span class="cl">	<span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside the setter&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">input_name</span>
</span></span></code></pre><p>그러면 동작은 위와 똑같이 하지만, 외부에서 <code>__name</code> 속성을 접근할 수 없다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">fowl</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">fowl</span><span class="o">.</span><span class="n">__name</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span><span class="o">...</span>
</span></span></code></pre><p>이 <code>__</code> 네이밍 컨벤션은 해당 속성을 private으로 만들지는 않지만, 해당 속성을 외부 코드에서 발견할 수 없도록 이름을 맹글링(mangling)한다.</p>
<p>(이름) 맹글링은 클래스 내에서 두 개의 밑줄(<code>__</code>)로 시작하고, 최대 한 개의 밑줄로 끝나는 속성 이름(예: <code>__name</code>)을 다른 이름으로 바꾸는(변환하는) 과정을 의미한다.
맹글링은 1. 이름 충돌 방지와 2. &quot;약한&quot; 프라이빗 효과를 준다.</p>
<p><strong>맹글링을 이용하면, 속성 이름이든 메서드 이름이든<code>__X</code> 를 <code>_클래스 이름__X</code> 이렇게 변환할 수 있다.</strong></p>
<p>하지만, 다음과 같이 접근할 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">fowl</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">fowl</span><span class="o">.</span><span class="n">_Duck__name</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;a&#39;</span>
</span></span></code></pre><p>더불어, 메서드 이름도 맹글링을 할 수 있긴 하다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TestExample</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">__class_attribute</span> <span class="o">=</span> <span class="s2">&#34;클래스 속성&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">__instance_attribute</span> <span class="o">=</span> <span class="s2">&#34;인스턴스 속성&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">__private_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;프라이빗 메서드 호출됨&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">public_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">TestExample</span><span class="o">.</span><span class="n">__class_attribute</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__instance_attribute</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__private_method</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">t</span> <span class="o">=</span> <span class="n">TestExample</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">public_method</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">_TestExample__instance_attribute</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">TestExample</span><span class="o">.</span><span class="n">_TestExample__class_attribute</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">_TestExample__private_method</span><span class="p">())</span>
</span></span></code></pre><p>즉, 네임 맹글링은 속성의 의도적인 직접 접근을 어렵게 만든다.
그러나, 이것이 속성을 완벽하게 보호할 수는 없다.
아직도 접근은 가능하기 때문이다.</p>
<h2>클래스와 객체 속성</h2>
<p>클래스에 속성을 할당할 수 있고(이를 클래스 속성이라고 부른다.), 해당 속성은 자식 객체로 상속된다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Fruit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">blueberry</span> <span class="o">=</span> <span class="n">Fruit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">Fruit</span><span class="o">.</span><span class="n">color</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;red&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">blue</span><span class="o">.</span><span class="n">berry</span><span class="o">.</span><span class="n">color</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;red&#39;</span>
</span></span></code></pre><p>클래스 자체 이름.속성 이렇게 클래스 자체에 할당된 속성을 사용할 수 있다. 왜냐하면 클래스도 객체이기 때문이다.
<strong>계속 강조한다. 클래스도 그냥 객체일 뿐이다. 그러나, 인스턴스를 만들 수 있는 특수한 객체라는 점이 특별한 것이다.</strong></p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Fruit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">blueberry</span> <span class="o">=</span> <span class="n">Fruit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">blueberry</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">blueberry</span><span class="o">.</span><span class="n">color</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;blue&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Fruit</span><span class="o">.</span><span class="n">color</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;red&#39;</span>
</span></span></code></pre><p>자식 객체의 속성을 변경하면 클래스 속성에 영향을 미치지 않는다.
다시 한 번 말한다. 객체의 속성도 나중에 변경 가능하다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Fruit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">blueberry</span> <span class="o">=</span> <span class="n">Fruit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Fruit</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">Fruit</span><span class="o">.</span><span class="n">color</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;a&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">blueberry</span><span class="o">.</span><span class="n">color</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;red&#39;</span>
</span></span></code></pre><p>클래스 속성을 변경해도 기존 자식 객체에는 영향을 미치지 않는다.
다시 한 번 말한다. 객체의 속성도 나중에 변경 가능하다.</p>
<h2>메서드 타입(종류)</h2>
<ul>
<li>메서드 앞에 데커레이터가 없다면 이것은 인스턴스 메서드다. 첫 번째 인수는 객체 자신을 참조하는 self다.</li>
<li>메서드 앞에 @classmethod 데커레이터가 있다면 클래스 메서드다. 첫 번째 인수는 클래스 자체를 참조하는 cls다.</li>
<li>메서드 앞에 @staticmethod 데커레이터가 있다면 정적 메서드다. 첫 번째 인수는 위와 같이 자신의 객체나 클래스가 아니다.</li>
</ul>
<h2>인스턴스 메서드</h2>
<p>클래스 정의에서 메서드의 첫 번째 인수가 self라면 이 메서드는 인스턴스 메서드(instance method)다.
인스턴스 메서드의 첫 번째 매개변수는 self이고, 파이썬은 이 메서드를 호출할 때 클래스로부터 생성된 객체(인스턴스)를 전달한다.
인스턴스 메서드를 쓰려면 self 첫 번째 인자가 인스턴스를 받으니까, 인스턴스를 무조건 꼭 생성해야 한다.</p>
<h2>클래스 메서드</h2>
<p><strong>클래스 메서드(Class Method)는 첫 번째 매개변수로 클래스 자신을 받으며, 관례적으로 이 매개변수를 <code>cls</code>라고 부른다.</strong>
클래스 매서드는 첫 번째 매개변수가 클래스 자기 자신인 것만 빼면, 인스턴스 메서드와 동일하다.</p>
<p>클래스 메서드(class method)는 클래스 전체에 영향을 미친다.
클래스 정의에서 함수에 @classmethod 데커레이터가 있다면 이것은 클래스 메서드다.
또한, 이 메서드의 첫 번째 매개변수는 클래스 자신이다.
파이썬에서는 보통 이 클래스의 첫 번째 매개변수를 cls로 쓴다.
class는 예약어이기에 사용이 불가능하기 때문이다.</p>
<p>클래스 메서드(<code>@classmethod</code>로 데코레이트된 메서드)는 호출될 때 <strong>항상 그 클래스 자신을 첫 번째 인자(argument)로 전달받는다.</strong> 이 첫 번째 인자는 관례적으로 <code>cls</code>라는 이름을 사용한다.</p>
<p>한 번, A 클래스에서 객체 인스턴스가 몇 개 만들어졌는지 알아보는 클래스 메서드를 정의해보자.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">A</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">exclaim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I&#39;m an A!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nd">@classmethod</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">kids</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A has&#34;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="s2">&#34;little objects.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">easy_a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">breezy_a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">wheezy_a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.</span><span class="n">kids</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">has</span> <span class="mi">3</span> <span class="n">little</span> <span class="n">objects</span><span class="o">.</span>
</span></span></code></pre><p><code>A.count</code>는 클래스 <code>A</code>의 데이터 속성이고, <code>A.kids</code>는 클래스 <code>A</code>의 메서드 속성입니다.</p>
<p>왜 클래스 메서드를 쓰는가?
인스턴스 메서드는 필수적으로 인스턴스를 생성해야 한다. 왜? self를 첫 번째 매개변수로 받으니까, self는 클래스로부터 생성된 인스턴스만 받으니까.
클래스 메서드는 <code>클래스이름.메서드이름()</code> 형태로 인스턴스를 생성하지 않고도 호출할 수 있다.
그래서 클래스 메서드를 쓰는 거다.
미쳤다. 매우 명료하다.</p>
<h2>정적 메서드</h2>
<p>정적 메서드(static method)는 클래스나 객체에 영향을 미치지 못한다.
이 메서드는 단지 편의를 위해 존재한다.
정적 메서드는 @staticmethod 데커레이터가 있고, 첫 번째 매개변수로 self가 cls가 없다.
매개변수는 0개 이상이다. 첫 번째 매개변수에 아무것도 전달하지 않아도 된다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CoyoteWeapon</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="nd">@staticmethod</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">commercial</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">CoyoteWeapon</span><span class="o">.</span><span class="n">commercial</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span></code></pre><h2>덕 타이핑</h2>
<p>파이썬은 다형성(polymorphism)을 느슨(loose)하게 구현했다. 이것은 클래스에 상관없이 같은 동작을 다른 객체에 적용할 수 있다는 것을 의미한다.</p>
<blockquote>
<p>프로그램 언어의 다형성(polymorphism)은 그 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들이 다양한 자료형에 속하는 것이 허가되는 성질을 가리킨다.</p>
</blockquote>
<blockquote>
<p>덕 타이핑(duck typing)은 동적 타이핑의 한 종류로, 객체의 변수 및 메소드의 집합이 객체의 타입을 결정하는 것을 말한다.</p>
</blockquote>
<p>새 Quote 클래스에서 같은 <code>__init__()</code> 이니셜라이저를 사용해보자. 클래스에 다음 두 메서드를 추가한다.</p>
<ul>
<li>who() 메서드는 저장된 person 문자열의 값을 반환한다.</li>
<li>says() 메서드는 특정 구두점과 함께 저장된 words 문자열을 반환한다.</li>
</ul>
<p>다음과 같이 구현하자.`</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Quote</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">person</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">person</span> <span class="o">=</span> <span class="n">person</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">=</span> <span class="n">words</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">who</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">person</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">says</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">QuestionQuote</span><span class="p">(</span><span class="n">Quote</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">says</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">+</span> <span class="s1">&#39;?&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ExclamationQuote</span><span class="p">(</span><span class="n">Quote</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">says</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span></code></pre><p>QuestionQuote와 ElxclamationQuote 클래스에서 초기화 함수를 쓰지 않았다.
그러므로 부모의 <code>__init__()</code> 메서드를 오버라이드 하지 않았다.
파이썬은 자동으로 부모 클래스 Quote의 <code>__init__()</code> 메서드를 호출해서 인스턴스 변수 person과 words를 저장한다.
=&gt; <strong>즉, 파이썬은 부모의 모든 자원을 오버라이드 하지 않을 경우는 다 사용한다.</strong>
그러므로 자식 클래스 QuestionQuote와 ExclamationQuote에서 생성된 객체의 self.words에 접근할 수 있다.</p>
<p>객체를 만들어서 결과를 살펴보자.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">hunter</span> <span class="o">=</span> <span class="n">Quote</span><span class="p">(</span><span class="s1">&#39;Elmer Fudd&#39;</span><span class="p">,</span> <span class="s2">&#34;I&#39;m hunting wabbits&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">hunter</span><span class="o">.</span><span class="n">who</span><span class="p">(),</span> <span class="s1">&#39;says:&#39;</span><span class="p">,</span> <span class="n">hunter</span><span class="o">.</span><span class="n">says</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">Elmer</span> <span class="n">Fudd</span> <span class="n">says</span><span class="p">:</span> <span class="n">I</span><span class="s1">&#39;m hunting wabbits.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">hunted1</span> <span class="o">=</span> <span class="n">QuestionQuote</span><span class="p">(</span><span class="s1">&#39;Bugs Bunny&#39;</span><span class="p">,</span> <span class="s2">&#34;What&#39;s up, doc&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">hunted1</span><span class="o">.</span><span class="n">who</span><span class="p">(),</span> <span class="s1">&#39;says:&#39;</span><span class="p">,</span> <span class="n">hunted1</span><span class="o">.</span><span class="n">says</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">Bugs</span> <span class="n">Bunny</span> <span class="n">says</span><span class="p">:</span> <span class="n">What</span><span class="p">;</span><span class="n">s</span> <span class="n">up</span><span class="p">,</span> <span class="n">doc</span><span class="err">?</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">hunted2</span> <span class="o">=</span> <span class="n">ExclamationQuote</span><span class="p">(</span><span class="s1">&#39;Daffy Duck&#39;</span><span class="p">,</span> <span class="s2">&#34;It&#39;s rabbit season&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">hunted2</span><span class="o">.</span><span class="n">who</span><span class="p">(),</span> <span class="s1">&#39;says:&#39;</span><span class="p">,</span> <span class="n">hunted2</span><span class="o">.</span><span class="n">says</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">Daffy</span> <span class="n">Duck</span> <span class="n">says</span><span class="p">:</span> <span class="n">It</span><span class="s1">&#39;s rabbit season!</span>
</span></span></code></pre><p>세 개의 서로다른 says() 메서드는 세 클래스에 대해 서로 다른 동작을 제공한다. 이것은 객체 지향 언어에서 전통적인 다형성의 특징이다. 더 나아가 파이썬은 who()와 says() 메서드를 갖고 있는 모든 객체에서 이 메서드를 실행할 수 있게 해준다. Quote 클래스와 관계없는 BabblingBrook 클래스를 정의해보자.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BabblingBrook</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">who</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s1">&#39;Brook&#39;</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">says</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s1">&#39;Babble&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">brook</span> <span class="o">=</span> <span class="n">BabblingBrook</span><span class="p">()</span>
</span></span></code></pre><p>다음 함수에서 obj 인수와 who()와 says() 메서드를 실행해보자.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">who_says</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="nb">print</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">who</span><span class="p">(),</span> <span class="s1">&#39;says&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">says</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">who_says</span><span class="p">(</span><span class="n">hunter</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Elmer</span> <span class="n">Fudd</span> <span class="n">says</span> <span class="n">I</span><span class="s1">&#39;m hunting wabbits.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">who_says</span><span class="p">(</span><span class="n">hunted1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Bugs</span> <span class="n">Bunny</span> <span class="n">says</span> <span class="n">What</span><span class="s1">&#39;s up, doc?</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">who_says</span><span class="p">(</span><span class="n">hunted2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Brook</span> <span class="n">says</span> <span class="n">Babble</span>
</span></span></code></pre><p>brook 객체는 다른 객체와 전혀 관계없다. 예전부터 이러한 행위를 덕 타이핑(duck typing)이라고 불렀다.</p>
<p>오리처럼 꽥꽥거리고 걷는다면, 그것은 오리다.</p>
<h2>매직 메서드</h2>
<p>a = 3 + 8과 같은 무언가를 입력했을 때, 값 3과 8이 정수 객체고, + 기호로 더하라는 것을 어떻게 알까? 그리고 name = &quot;Daffy&quot; + &quot; &quot; + &quot;Duck&quot;을 입력하면 문자열을 연결한다는 것을 어떻게 알까?
파이썬의 특수 메서드(매직 메서드)를 사용하여 이러한 연산자를 사용할 수 있다.
특수 메서드의 이름은 두 언더바로 시작하고 끝난다. 이러한 이름은 개발자가 이렇게 변수 이름을 짓지 않을 것이다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Word</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">word2</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">first</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="s1">&#39;ha&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">second</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="s1">&#39;HA&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">third</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="s1">&#39;eh&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">first</span><span class="o">.</span><span class="n">euqlas</span><span class="p">(</span><span class="n">second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">first</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">third</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kc">False</span>
</span></span></code></pre><p>문자열을 소문자로 바꿔서 비교하는 equals 메서드를 정의했다.
그러나, 파이썬의 내장된 타입 처럼 first == second 이렇게 비교했으면 편리했을 것이다.
한 번, equals 메서드를 특수 메서드 이름 <code>__eq__()</code> 로 바꿔보자.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Word</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">word2</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">first</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="s1">&#39;ha&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">second</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="s1">&#39;HA&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">third</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="s1">&#39;eh&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">first</span> <span class="o">==</span> <span class="n">second</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">first</span> <span class="o">==</span> <span class="n">third</span>
</span></span><span class="line"><span class="cl"><span class="kc">False</span>
</span></span></code></pre><p><code>__eq__()</code> 는 같은지 판별하는 파이썬의 특수 메서드 이름이다.
<strong>즉, <code>A.__eq__(B)</code> 라는 것을 <code>A == B</code> 이렇게 편리하게 할 수 있도록 하는 것이 특수 메서드의 역할이다.</strong></p>
<table>
<thead>
<tr>
<th>비교 연산 매직 메서드</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__eq__(self, other)</code></td>
<td>self == other</td>
</tr>
<tr>
<td><code>__ne__(self, other)</code></td>
<td>self != other</td>
</tr>
<tr>
<td><code>__lt__(self, other)</code></td>
<td>self &lt; other</td>
</tr>
<tr>
<td><code>__gt__(self, other)</code></td>
<td>self &gt; other</td>
</tr>
<tr>
<td><code>__le__(self, other)</code></td>
<td>self &lt;= other</td>
</tr>
<tr>
<td><code>__ge__(self, other)</code></td>
<td>self &gt;= other</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>산술 연산 매직 메서드</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__add__(self, other)</code></td>
<td>self + other</td>
</tr>
<tr>
<td><code>__sub__(self, other)</code></td>
<td>self - other</td>
</tr>
<tr>
<td><code>__mul__(self, other)</code></td>
<td>self * other</td>
</tr>
<tr>
<td><code>__floordiv__(self, other)</code></td>
<td>self // other</td>
</tr>
<tr>
<td><code>__truediv__(self, other)</code></td>
<td>self / other</td>
</tr>
<tr>
<td><code>__mod__(self, other)</code></td>
<td>self % other</td>
</tr>
<tr>
<td><code>__pow__(self, other)</code></td>
<td>self ** other</td>
</tr>
<tr>
<td>산술 연산자의 사용에는 제한이 없다.</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>기타 매직 메서드</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__str__(self, other)</code></td>
<td>str(self)</td>
</tr>
<tr>
<td><code>__repr__(self, other)</code></td>
<td>repr(self)</td>
</tr>
<tr>
<td><code>__len__(self, other)</code></td>
<td>len(self)</td>
</tr>
</tbody>
</table>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Word</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">word2</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span></span></code></pre><p>이러한 코드에서</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">first</span>
</span></span></code></pre><p>이렇게 <code>first</code> 와 같이객체 이름을 인터프리터에 직접 입력하게 되면 <code>__repr__()</code> 메직 메서드를 호출하게 됩니다.
만약 클래스에 <code>__repr__()</code>가 정의되어 있지 않으면 (또는 <code>object</code>로부터 상속받은 기본 구현만 있다면), <code>&lt;__main__.ClassName object at 0x...&gt;</code>와 같은 기본 문자열 표현이 사용된다. 이 기본 표현은 <code>object</code> 클래스의 <code>__repr__()</code> 메서드에서 제공된다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">str</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
</span></span></code></pre><p><code>print(first)</code> 나 <code>str(first)</code>이렇게 쓰면 <code>__str__</code> 메직 메서드가 실행된다.
단, 클래스에 <code>__str__()</code> 메서드가 정의되어 있지 않으면, <code>print()</code> 함수나 <code>str()</code> 함수는 대신 <code>__repr__()</code> 메서드를 사용한다.
만약 클래스에 <code>__repr__()</code>도 <code>__str__()</code>도 정의되어 있지 않으면 (또는 <code>object</code>로부터 상속받은 기본 구현만 있다면), <code>&lt;__main__.ClassName object at 0x...&gt;</code>와 같은 기본 문자열 표현이 사용된다. 이 기본 표현은 <code>object</code> 클래스의 <code>__repr__()</code> 메서드에서 제공된다.</p>
<p>즉, 모든 파이썬 객체는 <code>repr()</code> 함수를 통해 자신의 문자열 표현을 얻을 수 있는 방법을 가지고 있다.
더불어, <code>__str__()</code> 와 <code>__repr__()</code> 를 사용자가 정의할 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Word</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">word2</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s1">&#39;Word(&#34;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">+</span> <span class="s1">&#39;&#34;)&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">first</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="s1">&#39;ha&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">first</span> <span class="c1"># __repr__ 호출</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="c1"># __str__ 호출</span>
</span></span></code></pre><h2>애그리게이션과 콤퍼지션</h2>
<p>상속: 자식 is-a 부모
애그리게이션(aggregation)과 콤퍼지션(composition): X has-a Y</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bill</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Tail</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Duck</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bill</span><span class="p">,</span> <span class="n">tail</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">bill</span> <span class="o">=</span> <span class="n">bill</span> <span class="c1"># object</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span> <span class="c1"># object</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">about</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;This duck has a&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bill</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="s1">&#39;bill and a&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="s1">&#39;tail&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a_tail</span> <span class="o">=</span> <span class="n">Tail</span><span class="p">(</span><span class="s1">&#39;long&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">a_bill</span> <span class="o">=</span> <span class="n">Bill</span><span class="p">(</span><span class="s1">&#39;wide orange&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">duck</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="n">a_bill</span><span class="p">,</span> <span class="n">a_tail</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">duck</span><span class="o">.</span><span class="n">about</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">This</span> <span class="n">duck</span> <span class="n">has</span> <span class="n">a</span> <span class="n">wide</span> <span class="n">orange</span> <span class="n">bill</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">long</span> <span class="n">tail</span>
</span></span></code></pre><p>애그리게이션은 관계를 표현하지만 조금 더 느슨하다. 한 객체는 다른 객체르 사용하지만, 둘다 독립젹으로 존재한다.</p>
<h2>객체, 모듈은 언제 사용할까?</h2>
<ul>
<li>비슷한 행동(메서드)을 하지만 내부 상태(속성)가 다른 개별 인스턴스가 필요할 때, 객체는 매우 유용하다.</li>
<li>클래스는 상속을 지원하지만, 모듈은 상속을 지원하지 않는다.</li>
<li>어떤 한 가지 일만 수행한다면 모듈이 가장 좋은 선택일 것이다. 프로그램에서 파이썬 모듈이 참조된 횟수에 상관없이 단 하나의 복사본만 불러온다(싱글톤(singleton)처럼 쓸 수 있다.)</li>
<li>여러 함수에 인수로 전달하는 여러 변수가 있다면, 클래스를 정의하는 것이 더 좋다. 예를 들어 화상 이미지를 나타내기 위해 size, color를 딕셔너리의 키로 사용한다고 가정해보자. 프로그램에서 각 이미지에 대한 딕셔너리를 생성하고, scale(), transform() 같은 함수에 인수를 전달할 수 있다. 키와 함수를 추가하면 코드가 지저분해질 수도 있다. size, color를 속성으로 하고 scale(), transform()을 메서드로 하는 이미지 클래스를 정의하는 것이 더 일관성이 있다. 색상 이미지에 대한 모든 데이터와 메서드를 한 곳에 정의할 수 있기 때문이다.</li>
<li>가장 간단한 문제 해결법을 사용한다. 딕셔너리, 리스트, 튜플은 모듈보다 더 작고 간단하며 빠르다. 그리고 일반적으로 모듈은 클래스보다 더 간단하다.</li>
<li>귀도의 조언: 자료구조를 과하게 엔지니어링하는 것을 피해해야 한다. 객체보다 튜플이 더 낫다(네임드 튜플을 써보라). getter/setter 함수보다 간단한 필드(field)가 더 낫다. 내장된 데이터 타입은 우리 친구다. 숫자, 문자열, 튜플, 리스트, 셋, 딕셔너리를 사용하라. 또한 데크와 같은 컬렉션 라이브러리를 활용하라.</li>
<li>새로운 대안은 데이터 클래스다.</li>
</ul>
<h2>네임드 튜플</h2>
<p>네임드 튜플은 튜플의 서브 클래스다.
네임드 튜플은 이름(.name)과 위치(<code>[offset]</code>)로 값에 접근할 수 있다.
네임드 튜플은 모듈(from collections import namedtuple)을 불러와야 한다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
</span></span><span class="line"><span class="cl"><span class="n">Duck</span> <span class="o">=</span> <span class="n">nametuple</span><span class="p">(</span><span class="s1">&#39;Duck&#39;</span><span class="p">,</span> <span class="s1">&#39;bill tail&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">duck</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="s1">&#39;wide orange&#39;</span><span class="p">,</span> <span class="s1">&#39;long&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">duck</span>
</span></span><span class="line"><span class="cl"><span class="n">Duck</span><span class="p">(</span><span class="n">bill</span><span class="o">=</span><span class="s1">&#39;wide orange&#39;</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;long&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">duck</span><span class="o">.</span><span class="n">bill</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;wide orange&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">duck</span><span class="o">.</span><span class="n">tail</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;long&#39;</span>
</span></span></code></pre><p>딕셔너리에서 네임드 튜플을 만들 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
</span></span><span class="line"><span class="cl"><span class="n">Duck</span> <span class="o">=</span> <span class="n">nametuple</span><span class="p">(</span><span class="s1">&#39;Duck&#39;</span><span class="p">,</span> <span class="s1">&#39;bill tail&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">parts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bill&#39;</span><span class="p">:</span><span class="s1">&#39;wide orange&#39;</span><span class="p">,</span><span class="s1">&#39;tail&#39;</span><span class="p">:</span><span class="s1">&#39;long&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">duck2</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="o">**</span><span class="n">parts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">duck2</span>
</span></span><span class="line"><span class="cl"><span class="n">Duck</span><span class="p">(</span><span class="n">bill</span><span class="o">=</span><span class="s1">&#39;wide orange&#39;</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;long&#39;</span><span class="p">)</span>
</span></span></code></pre><p><code>**parts</code> 는 키워드 인수다. parts 딕셔너리에서 키와 값을 추출하여 Duck()의 인수로 제공한다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">parts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bill&#39;</span><span class="p">:</span><span class="s1">&#39;wide orange&#39;</span><span class="p">,</span><span class="s1">&#39;tail&#39;</span><span class="p">:</span><span class="s1">&#39;long&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">duck2</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="o">**</span><span class="n">parts</span><span class="p">)</span>
</span></span></code></pre><p>즉, 이것과</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">duck2</span> <span class="o">=</span> <span class="n">Duck</span><span class="p">(</span><span class="n">bill</span> <span class="o">=</span> <span class="s1">&#39;wide orange&#39;</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="s1">&#39;long&#39;</span><span class="p">)</span>
</span></span></code></pre><p>이것은 같은 효과를 내는 코드이다.</p>
<p>네임드 튜플은 불변이다.
하지만 필드를 바꿔서 또 다른 네임드 튜플을 반환할 수 있다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">duck3</span> <span class="o">=</span> <span class="n">duck2</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">tail</span><span class="o">=</span><span class="s1">&#39;magnificent&#39;</span><span class="p">,</span> <span class="n">bill</span><span class="o">=</span><span class="s1">&#39;curshing&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">duck3</span>
</span></span><span class="line"><span class="cl"><span class="n">Duck</span><span class="p">(</span><span class="n">bill</span><span class="o">=</span><span class="s1">&#39;crushing&#39;</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;magnificent&#39;</span><span class="p">)</span>
</span></span></code></pre><p>네임드 튜플은 불변이다.
이렇게 오류가 난다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="n">duck</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span><span class="o">....</span>
</span></span></code></pre><p>네임드 튜플의 특징을 정리하면 다음과 같다.</p>
<ul>
<li>불변 객체처럼 행동한다.</li>
<li>객체보다 공간 효율성과 시간 효율성이 더 좋다.</li>
<li>대괄호 대신, 온점 표기법으로 속성에 접근할 수 있다.</li>
<li>네임드 튜플을 딕셔너리의 키처럼 쓸 수 있다.</li>
</ul>
<p>단, 네임드 튜플은 속성만 저장할 수 있다. 메서드는 저장할 수 없다.</p>
<h2>데이터 클래스</h2>
<p>데이터 클래스도 모듈(from dataclasses import dataclass)을 불러와한다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TeenyClass</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="n">teeny</span> <span class="o">=</span> <span class="n">TeenyClass</span><span class="p">(</span><span class="s1">&#39;itsy&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">teeny</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;itsy&#39;</span>
</span></span></code></pre><p>이것을 데이터클래스로 바꾸면,</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
</span></span><span class="line"><span class="cl"><span class="nd">@dataclass</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TeenyDataClass</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">teeny</span> <span class="o">=</span> <span class="n">TeenyDataClass</span><span class="p">(</span><span class="s1">&#39;bitsy&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">teeny</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;bitsy&#39;</span>
</span></span></code></pre><p><code>name: type</code> 같은 형식의 변수 어노테이션을 사용하여 클래스 속성을 정의한다.</p>
<p>데이터 클래스 객체를 생성할 때, 클래스에 저장된 순서대로 인수를 제공하고 이름이 지정된 인수를 임의의 순서로 제공해야 한다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
</span></span><span class="line"><span class="cl"><span class="nd">@dataclass</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnimalClass</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</span></span><span class="line"><span class="cl">	<span class="n">habitat</span><span class="p">:</span> <span class="nb">str</span>
</span></span><span class="line"><span class="cl">	<span class="n">teeth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 기본값 지정</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">snowman</span> <span class="o">=</span> <span class="n">AnimalClass</span><span class="p">(</span><span class="s1">&#39;yeti&#39;</span><span class="p">,</span> <span class="s1">&#39;Himalayas&#39;</span><span class="p">,</span> <span class="mi">46</span><span class="p">)</span> <span class="c1"># 위치 인수 # name = &#39;yeti&#39; habitat = &#39;himalayas&#39; teeth = 46</span>
</span></span><span class="line"><span class="cl"><span class="n">duck</span> <span class="o">=</span> <span class="n">AnimalClass</span><span class="p">(</span><span class="n">habitat</span><span class="o">=</span><span class="s1">&#39;lake&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;duck&#39;</span><span class="p">)</span> <span class="c1"># 키워드 인수</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">snowman</span><span class="o">.</span><span class="n">teeth</span>
</span></span><span class="line"><span class="cl"><span class="mi">46</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">duck</span><span class="o">.</span><span class="n">habitat</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;lake&#39;</span>
</span></span></code></pre><p>데이터클래스는 이렇게 메서드를 추가할 수 있긴 하다.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
</span></span><span class="line"><span class="cl"><span class="nd">@dataclass</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># 필드 정의</span>
</span></span><span class="line"><span class="cl">	<span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
</span></span><span class="line"><span class="cl">	<span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># 사용자 정의 메서드 추가</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dy</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="s2">&#34;&#34;&#34;점 P를 dx, dy만큼 이동시킵니다.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dx</span>
</span></span><span class="line"><span class="cl">		<span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">dy</span>
</span></span></code></pre><h2>attrs</h2>
<p><code>attrs</code>는 파이썬에서 클래스를 보다 쉽게 정의하고 관리할 수 있도록 해주는 라이브러리이다.</p>
</article>
                </div>
                <section class="post-comments">
                    <script src="https://giscus.app/client.js"
                            data-repo="chebread/chebread.github.io"
                            data-repo-id="R_kgDOP0JptQ"
                            data-category="Announcements"
                            data-category-id="DIC_kwDOP0Jptc4CwG8I"
                            data-mapping="title"
                            data-strict="0"
                            data-reactions-enabled="1"
                            data-emit-metadata="0"
                            data-input-position="top"
                            data-theme="light"
                            data-lang="ko"
                            crossorigin="anonymous"
                            async>
                    </script>
                </section>
            </main>

            <footer class="post-footer">
                <section>
                    <p>&copy; 2025 Cha Haneum</p>
                </section>
                <section>
                    <a href="https://github.com/chebread">
                        <span>깃허브</span>
                    </a>
                    <a href="">
                        <span>이메일</span>
                    </a>
                </section>
            </footer>
        </div>
    </div>

    <script src="/js/main.js"></script>
</body>
</html>