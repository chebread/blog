---
date: 2025-05-10
category: [Python 문법 정리]
published: true
fixed: false
---

## 자료구조
데이터 타입은 원자이고, 자료구조는 분자이다.

파이썬에서 자료구조는 튜플, 리스트, 딕셔너리, 셋이 있다.

## 시퀀스
시퀀스란 데이터를 순서대로 나열한 것을 의미한다.

파이썬에서는 3가지의 시퀀스 타입(문자열, 리스트, 튜플)이 있다.

모든 시퀀스는 순서가 유지되며, 정수 인덱싱을 지원하고, 길이가 존재한다.

문자열은 문자의 시퀀스이다.

리스트와 튜플은 모든 것의 시퀀스이다.

리스트와 튜플은 0개 이상의 항목을 포함한다.

리스트와 튜플의 항목(item) 또는 요소(element)는 다른 타입, 다른 객체가 될 수 있다.

**즉, 각 요소들은 다른 타입을 가질 수 있다.**

튜플과 리스트의 차이점은,

튜플은 불변(immutable)이지만, 리스트는 가변(mutable)이다.

튜플에 항목을 할당하고 나면 바꿀 수 없다. 리스트는 항목을 할당하고 나서 자유롭게 수정하거나 삭제할 수 있다.

## 튜플
튜플은 다양한 방법으로 생성할 수 있다.

튜플을 생성하는 방법은 비일관적(inconsistent)이다.

튜플을 정의할 때는 괄호가 필요 없다.

**튜플을 정의하는 진짜 핵심 문법은 괄호가 아니라 쉼표다.**

**즉, 튜플을 선언하는 방법은 요소 뒤에 콤마를 붙이는 것이다.**

하나 요소 이상의 튜플을 만들기 위해서는 각 요소 뒤에 콤마를 붙인다.

요소가 두 개 이상이라면 마지막 요소에는 콤마를 붙이지 않는다.

단, 요소가 하나라면 마지막 요소이자 첫번째 요소에는 콤마를 붙여야 한다.

`'a', ` 이렇게 써도 각 요소 뒤에 콤마를 붙이는 것이 튜플의 정의 방식이므로 요소는 1개 짜리 튜플이 된다.

요소가 하나이고 괄호를 붙여도 이는 튜플이 되지 않는다.

**괄호는 혼동 방지용 시각적 도구일 뿐이다.**

**튜플 정의의 핵심은 콤마이다.**

```python
a = 'G',
tuple

b = 'G'
string

c = ('k',)
tuple

d = ('k')
string
```

이렇게, 만약 요소가 하나인데도 콤마를 붙이지 않았다면 이는 다른 타입으로 취급될 수 있다.

**그러나 튜플에 괄호를 쓰는 이유는, 튜플인지 구분하기 더 쉬워지기 때문이다.**

그래서 파이썬에서는 튜플을 출력할 때 괄호를 포함한다.

그러나, 튜플을 선언할때는 괄호는 써도 되도 안써도 된다.

괄호는 선택적이며, 혼동 방지용 시각적 도구일 뿐이다.

그러나, 빈 튜플을 만들때는 `()` 혹은 `tuple()` 로 선언한다. 쉼표를 사용해서 빈 튜플을 만들 수는 없다.

**그러나, 함수, 메서드 인수 등 같이 콤마를 다른 용도로 사용하려면 튜플을 직접 정의하여 사용할 때 괄호가 필요하다.**

> 솔직히 생각만 해보면 당연한 것이다.

```python
one_marx = 'G',
type(one_marx)
tuple

type('G', )
string

type(('G', ))
tuple

```

즉, 함수나 메서드 인수에서는 콤마로 인수를 구분한다.

그런데 튜플을 사용할때 만약 괄호로 튜플인 것을 명시하지 않으면 함수는 각 구분된 튜플 요소를 인수로 취급해버린다.

그래서 이런 콤마를 다른 용도로 사용하는 상황에서는 반드시 튜플을 괄호로 묶어야 한다.

그러나, 위처럼 변수에 튜플을 저장하고 이를 인수로서 활용하는 상황에서는 괄호는 선택사항이다.

**오로지 인수에 직접 튜플을 대입해서 사용하는 경우에만 괄호가 필요하다.**

근데, 의문이 들 수도 있다.

type('G',)라고 쓰면 인자가 두 개를 전달한 것이 아니라 하나만 전달한 것이니까 에러가 발생하는 거 아닌가?

아니다. 파이썬은 전달된 인자의 **개수**를 기준으로 함수 호출을 처리하지, 인자에 “대입되지 않았다”고 해서 에러를 내지 않는다.

즉, 파이썬에서는 "함수에 전달된 인자의 개수와 그 인자들이 함수에 정의된 인자의 개수와 일치하는가?"만 신경쓴다.

## 튜플 언패킹
튜플을 사용하여 한 번에 여러 변수에 값을 할당할 수 있다.

이를 튜플 언패킹이라고 부른다.

```python
marx_tuple = ('a', 'b', 'c')
a, b, c = marx_tuple

>>> a
'a'

>>> b
'b'

>>> c
'c'
```

튜플 언패킹을 활용하여, 한 라인에서 값을 교환하기 위해 임시변수를 사용하지 않고 튜플을 사용하여 값을 교환할 수 있다.

```python
a = 'a'
b = 'b'
a, b = b, a

>>> a
'b'

>>> b
'a'
```

## 시퀀스 언패킹(이터러블 언패킹)
시퀀스 언패킹(이터러블 언패킹)은 이터러블(iterable)의 각 항목을 개별 변수에 할당하는 기능을 말합니다.
즉, 할당문의 왼쪽에 여러 변수를 놓고, 오른쪽에 있는 이터러블의 각 요소를 이 변수들에 차례대로 할당하는 것이다.
튜플 언패킹, 리스트 언패킹, ... 모두 통칭하여 시퀀스 언패킹이라고 부른다.
이터러블 언패킹 시, 변수의 개수와 이터러블 요소의 개수가 다를 경우(많거나 또는 적거나), Python은 에러를 발생시키니다.
즉, 이터러블 언패킹 시 변수는 이터러블의 요소와 같은 개수가 있어야 한다.
```python
a, b = [1, 2]        # 리스트 언패킹
a, b = (1, 2)        # 튜플 언패킹
a, b = 'AB'          # 문자열 언패킹
a, b = range(2)      # range 언패킹
```
참고로 `range()` 는 불변 시퀀스 타입이기에 가능하다.

## 시퀀스 언패킹 연산자(이터러블 언패킹 연산자)
시퀀스 언패킹 연산자 `*`는 이터러블 객체를 풀어서 개별 요소로 분리할 때 사용한다.

```python
#활용 1
my_list = [1, 2, 3, 4, 5]
a, *rest, c = my_list
print(rest) # 결과 : [2, 3, 4]

#활용 2
def func(a, b, c):
  print(a, b, c)

my_list2 = [1, 2, 3]
func(*my_list2) #결과 : 1 2 3
```

## tuple()
`tuple()` 함수는 다른 객체를 튜플로 만들어 준다.

```python
>>> marx_list = ['a', 'b', 'c']
>>> tuple(marx_list)
('a', 'b', 'c')
```

`tuple()` 함수로 빈 튜플을 생성할 수 있다.

```python
>>> a = tuple()
()
```

## 튜플 결합하기
`+` 연산자를 사용하여 튜플을 결합할 수 있다.

튜플을 결합하여 새 튜플을 만들 수 있다.

```python
>>> ('a', ) + ('b', 'c')
('a', 'b', 'c')
```

## 튜플 항목 복제하기
`*` 연산자를 사용하여 튜플의 전체 항목을 복제할 수 있다.

튜플을 복제하여 새 튜플을 만들 수 있다.

```python
('a', 'b') * 3
('a', 'b', 'a', 'b', 'a', 'b')
```

## 튜플 비교하기
`tuple1 == tuple2` 은 `tuple1` 튜플과 `tuple2` 튜플의 모든 요소가 순서대로 동일한지 확인한다.

`tuple1 >(=) tuple2` or `tuple1 <(=) tuple2` 은 튜플의 요소들의 크기를 순서대로 비교하여 튜플의 크기를 비교한다.

비교되는 튜플의 요소들은 같은 타입이어야 한다. 타입이 다른 경우, 비교는 의미가 없거나 예상치 못한 결과가 나올 수 있다.

만약 튜플에 속한 요소들의 타입이 문자열이라면, 파이썬은 요소를 차례대로 사전식(lexicographical)으로 비교한다.

즉, 문자열끼리의 비교가 그대로 적용된다.

근데,
```python
>>> 'a', > 'b',
  File "<python-input-10>", line 1
    'a', > 'b',
         ^
SyntaxError: invalid syntax
```

여기서 왜 에러가 뜰까?

**연산 과정에서 'a', 를 튜플로 취급해버리지 않게 되기 때문이다.**

이는 위의 함수 인수 전달과 비슷하다고 볼 수 있다.

그러므로 대부분의 경우에는 괄호로 튜플이라는 것을 명확히 선언하는 편이 좋다.

그래서 위의 튜플을 괄호로 묶어주면 에러는 해결된다.

```python
>>> ('a',) > ('b',)
False
```

## 튜플 순회하기
튜플 순회는 다른 타입과 똑같이 동작한다.

for in 문으로 순회할 수 있다.

```python
words = 'a', 'b', 'c'
for word in words:
	print(word)
'a'
'b'
'c'
```

## 튜플 수정하기
튜플 객체는 수정이 불가능하다.

**주의해야 할 것은 튜플 객체 자체는 수정이 불가능하지만, 튜플을 참조하는 변수는 다른 튜플로 변경이 가능하다는 것이다.**

```python
a = 'a',
b = 'b',
a += b # a = a + b
('a', 'b')
```

여기서 `a` 변수는 처음에는 `'a',` 튜플을 참조하고, `b` 변수는 `'b',` 튜플을 참조한다.

`a += b` 로 `a + b` 튜플 연산을 진행하고 `'a', 'b'` 튜플을 `a` 변수가 참조하게 된다.

**즉, 객체는 불변이지만, 변수는 가리키는 대상을 변경할 수 있는 것이다.**

`a = 'A'` 를 `a = 3` 으로 변경할 수 있는 것도 같은 이유이고, 같은 원리이다.

> 어려운 것은 쉬운 예시를 사용하여 이해하자.

파이썬은 변수에 객체를 할당할 때 얼마든지 다른 타입의 객체도 할당을 할 수 있다.

변수는 불변이 아니다. 변수는 언제나 참조하는 객체를 변경할 수 있다.

**`id()` 함수는 객체의 고유값을 반환한다.**

`id()` 함수를 사용하여 정말 `a` 변수가 새로운 값을 가리키고 있는지 확인 가능하다.

```python
t1 = 'a',
t2 = 'b',
id(t1)
4...2
t1 += t2
id(t1)
4...4
```

## 리스트
리스트는 데이터를 순차적으로 파악하는 데 유용하다.

리스트는 0개 이상의 요소를 가진다.

리스트는 콤마로 구분하고 대괄호로 감싸서 정의한다.

```python
list1 = []
list2 = [3, 2, 'a']
```

## list()
`list()` 함수는 다른 데이터 타입(튜플, 문자열, 셋, 딕셔너리 등)을 리스트로 변환한다.

```python
list('cat')
['c', 'a, 't']
```

`list()` 함수를 사용하여 빈 리스트를 만들 수 있다.

```python
list = list()
[]
```

위의 예제를 보고 이상하다고 생각할 수 있다.

왜 결과가 `['cat']`가 아닌가?

**이유는, `list()` 함수는 이터러블 객체를 받아, 그 각 요소를 하나씩 꺼내서 리스트의 요소로 만든다.**

그래서 문자열은 이터러블이기에 문자열을 순회하여 리스트의 요소로 만든 것이다.

## 리스트 항목 얻기
문자열과 마찬가지로 리스트는 오프셋으로 특정 요소를 추출할 수 있다.

양수 인덱스는 0번째부터 시작한다.

```python
list = ['a', 'b', 'c']
list[0]
'a'
```

문자열과 마찬가지로 음수 인덱스는 끝에서부터 거꾸로 값을 추출한다.

음수 인덱스는 -1번째 부터 시작한다.

```python
list = ['a', 'b', 'c']
list[-1]
'c'
```

리스트 오프셋은 값을 할당한 위치에 맞게 입력되어야 한다.

**리스트 오프셋의 위치가 리스트의 범위를 벗어나면 예외(에러)가 발생한다.**

```python
>>> list = ['a', 'b']
>>> list[2]
Traceback (most recent call last):
  File "<python-input-1>", line 1, in <module>
    list[2]
    ~~~~^^^
IndexError: list index out of range
```

## 슬라이스로 항목 얻기
문자열에서 사용했던 슬라이스 처럼, 슬라이스를 사용해서 리스트의 서브시퀀스를 추출할 수 있다.

```python
list = ['a', 'b']
list[0:2]
['a', 'b']
```

리스트의 슬라이스도 리스트다.

문자열과 마찬가지로 슬라이스에 스텝을 사용할 수 있다.

```python
list = ['a', 'b']
list[::1]
['a', 'b']
```

스텝을 사용해서 리스트를 반대로 뒤집을 수도 있다.

```python
list = ['a', 'b']
list[::-1]
['b', 'a']
```

슬라이스는 서브시퀀스를 반환만 할뿐, 슬라이스한 리스트에는 영향을 미치지는 않는다.

그러나, 슬라이스로 리스트를 수정할 수도 있다.

슬라이스는 유효한 범위의 인덱스를 반환하거나, 빈 리스트를 반환한다. 예외는 발생하지 않는다.

## 리스트 뒤집기: reverse()
`reverse()` 함수를 사용해서 리스트 자체를 반대로 뒤집을 수 있다.

`reserve()` 함수는 리스트 자체를 변경하지만, 변경한 값을 반환하지는 않는다.

이렇게 원본 자체를 변경하는 것을 "파괴적 연산(in place, destructive)"이라고 한다.

원본 자체를 변경하지 않는 것을 "비파괴적 연산(non-destructive)"이라고 한다.

```python
>>> list = ['a', 'b']
>>> list.reverse()
>>> list
['b', 'a']
```

## 리스트 끝에 항목 추가: append()
`append(항목)` 함수는 리스트 자체 끝에 새 항목을 하나 추가한다.

`append()` 함수는 인자를 하나만 받으며, 인자로 어떤 데이터 타입도 올 수 있다.

`append()` 함수는 원본 데이터를 변경하므로 파괴적 연산 함수이다.

```python
list = []
list.append(3)
[3]
list.append([2, 1])
[3, 2, 1]
```

## 리스트 특정 위치에 항목 추가:  insert()
`append()` 함수는 리스트 끝에 항목을 추가하지만,

`insert(오프셋, 항목)` 함수는 원하는 오프셋 위치에 항목을 추가할 수 있다.

추가할 위치가 리스트의 끝을 넘으면, 파이썬은 예외를 발생시키지 않고 리스트 마지막에 항목을 추가한다.

```python
a = ['a', 'b', 'c']
a.insert(0, 'k')
['k', 'a', 'b', 'c']
```

## 리스트 복제하기: *
`*` 연산자를 사용하여 리스트의 전체 항목을 복제할 수 있다.

리스트를 복제하여 새 리스트를 만들 수 있다.

```python
['a', 'b'] * 3
['a', 'b', 'a', 'b', 'a', 'b']
```

## 리스트 병합하기: extend(), +
extend() 함수를 사용하여 다른 리스트를 병합할 수 있다.

x.extend(a) 하면 x 리스트에 a 요소가 추가된다.

```python
a = [1, 2]
b = [3]
a.extend(b)
a
[1, 2, 3]
```

또한 +나 +=로 리스트를 병합할 수 있다.

```python
a = [1, 2]
b = [3]
a += b
a
[1, 2, 3]
```

append() 함수를 사용하여 항목을 병합하지 않고 하나의 리스트 요소로 추가된다.

```python
a = [1, 2]
b = [3]
a.append(b)
a
[1, 2, [3]]
```

## 오프셋으로 리스트 항목 변경
**오프셋으로 항목을 얻어 항목을 바꿀 수 있다.**

```python
a = [1, 2]
a[1] = 3
a
[1, 3]
```

단, 없는 항목을 오프셋으로 추가하는 것은 예외를 발생한다.

```python
a = [1, 2]
a[2] = 3
Traceback (most recent call last):
  File "<python-input-15>", line 1, in <module>
    a[2] = 3
    ~~~~^^^
IndexError: list assignment index out of range
```

즉, `list[i] = value` 는 특정 항목의 값을 변경하는 것이고,
`value = list[i]` 는 특정 항목을 값을 가져오는 것이다.

> 둘의 차이점을 명확히 하자.

## 슬라이스로 리스트 항목 변경
**슬라이스 구문은 할당 연산자과 함께 쓰일 때는 조회가 아닌, 수정 역할을 할 수 있다.**

```python
numbers = [1, 2, 3, 4]
numbers[1:3] = [8, 9]
numbers
[1, 8, 9, 4]
```

**리스트에 할당되는 슬라이스의 오른쪽 값의 수는 왼쪽 슬라이스 항목 수와 달라도 된다.**

**초과되는 부분은 자동으로 뒤에 추가 한다. 그리고 뒤의 항목은 보존된다.**

```python
numbers = [1, 2, 3, 4]
numbers[1:3] = [8, 9, 0]
numbers
[1, 8, 9, 0, 4]
```

슬라이스의 오른쪽 값은 리스트가 아니여도 된다. 순회 가능한(이터러블) 타입 값을 리스트 항목에 할당할 수 있다.

```python
numbers = [1, 2, 3, 4]
numbers[1:3] = (8, 9, 0)
numbers
[1, 8, 9, 0, 4]

numbers = [1, 2, 3, 4]
numbers[1:3] = 'what?'
numbers
[1, w, h, a, t, ?, 4]
```

## 오프셋으로 리스트 항목 삭제하기: del
`del list[offset]` 이렇게 특정 항목을 오프셋으로 삭제할 수 있다.

del은 리스트 메서드가 아니라 파이썬 구문이다.

`list[offset].del()`을 수행할 수 없다.

**del은 할당(=)의 반대다.**

`del 변수` 형태의 코드는 자료형에 상관없이 기본적으로 해당 변수의 선언 자체를 무효화 시킨다.

아니면 `del 변수의 항목`으로 자료형에 속한 항목을 무효화시킬 수도 있다.

그러나 `del string의 항목`은 삭제할 수 없다.

즉, `del "hello"[0]`는 안된다는 말이다.

## 값으로 리스트 항목 삭제하기: remove()
리스트에서 삭제할 항목의 오프셋을 모른다면, `remove(값)` 함수로 값으로 항목을 삭제할 수 있다.

```python
numbers = [1, 2, 3, 4]
numbers.remove(1)
numbers
[2, 3, 4]
```

만약 리스트에 같은 값으로 항목이 중복된다면, `remove()` 는 첫 번째 항목만 삭제한다.

## 오프셋으로 리스트 항목을 얻은 후 삭제하기: pop()
`pop()` 함수는 리스트에서 항목을 가져오는 동시에 그 항목을 삭제한다.

`list.pop(offset)` 의 형태로 사용하고, 만약 인수에 오프셋이 없다면 기본값은 `-1` 이다.

`list.pop(0)` 는 리스트의 head를 반환한다.
그리고 `list.pop()` or `list.pop(-1)` 은 리스트의 tail을 반환한다.

```python
numbers = [1, 2, 3, 4]
numbers.pop(0)
numbers
[2, 3, 4]
numbers.pop()
numbers
[2, 3]
numbers.pop(-1)
[2]
```

스택(Stack) 자료구조: append()로 새로운 항목을 끝에 추가한 뒤 pop()으로 다시 마지막 항목을 제거했다면, 후입 선출(LIFO) 자료구조인 스택을 구현한 것이다. 수집한 데이터에서 가장 오래된 것을 먼저 사용할때는 LIFO가 유용하다.

큐(Queue) 자료구조: append()로 새로운 항목을 끝에 추가한 뒤 pop(0)으로 처음 항목을 제거했다면, 선입 선출(FIFO) 자료구조인 큐를 구현한 것이다. 수집한 데이터에서 최근 것을 먼저 사용할 때는 FIFO가 유용하다.

## 모든 리스트 항목 삭제하기: clear()
`clear()` 함수를 사용하여 모든 항목을 지울 수 있다.

```python
numbers = [1, 2, 3, 4]
numbers.clear()
numbers
[]
```

`list = []` 처럼 빈 리스트를 할당하여 모든 항목을 지울 수도 있다.
```python
numbers = []
numbers
[]
```

## 값으로 리스트 오프셋 찾기: index()
`index()` 함수를 사용하여 리스트 항목 값의 오프셋을 알 수 있다.

```python
numbers = [1, 2, 3, 4]
numbers.index(1)
0
```

리스트에 같은 값이 2개 이상이면 첫 번째 오프셋만 반환한다.

```python
numbers = [1, 1, 2, 3, 4]
numbers.index(1)
0
```

## 리스트 값의 존재여부 확인하기: in()
리스트에서 어떤 값을 존재를 확인하기 위해 `in` 을 사용한다.

`a in x` 라고 하면 `x` 에 `a` 가 있는가를 알 수 있다.

존재 여부는 불리언 값으로 반환한다.

```python
numbers = [1, 1, 2, 3, 4]
1 in numbers
True
5 in numbers
False
```

리스트에서는 같은 값이 여러 개 존재할 수 있다.

리스트에 값이 적어도 하나 이상 존재하면 True를 반환한다.

## 리스트의 값 개수 세기: count()
리스트에 특정 항목이 얼마나 있는지 세기 위해 `count(특정 항목)` 함수를 사용한다.

```python
numbers = [1, 1, 2, 3, 4]
numbers.count(1)
2
```

특정 항목이 존재하지 않으면 `0` 을 반환한다.

## 리스트 정렬하기: sort(), sorted()
`sort()` 는 리스트 자체를 내부적으로(in place) 정렬한다.
`sort()` 는 값을 반환하지 않는다.
`sort()` 는 파괴적 연산이다.

`sorted()` 는 리스트의 정렬된 복사본을 반환한다.
`sorted()` 는 비파괴적 연산이다.

```python
a = [2, 1]
b = [2, 1]
a.sort()
a
[1, 2]

b.sorted()
[1, 2]
b
[2, 1]
```

정렬시에 리스트의 항목이 숫자라면 오름차순으로 정렬한다.
문자열이라면 알파벳순으로 정렬한다.

정수와 부동소수점 숫자 같이 혼합된 타입도 정렬할 수 있다.

파이썬이 자동으로 타입을 변환해서 항목들을 정렬해준다.

```python
numbers = [2, 1, 4.0, 3]
numbers.sort()
numbers
[1, 2, 3, 4.0]
```

내림차순으로 정렬하고 싶다면 sort(), sorted() 인수에 reverse=True를 추가하면 된다.

```python
numbers = [2, 1, 4.0, 3]
numbers.sort(reverse=True)
numbers
[4.0, 3, 2, 1]
```

## 리스트 항목 개수 얻기: len()
`len()` 은 리스트의 전체 항목 수를 반환한다.
```python
a = [1, 2, 3]
len(a)
3
```

빈 리스트면 `0` 을 반환한다.

## 할당하기: =
한 리스트를 변수 두 곳에 할당했을 때, 한 리스트를 변경하면 다른 리스트도 같이 변경된다.

**이를 얕은 복사라 한다.**

얕은 복사라는 것은 변수를 복사했다고 생각했지만 실제로는 서로 연결되어있는 것을 의미한다.

즉, 이렇게 복사를 했음에도, 값을 변경하면 다른 변수에도 영향을 끼치도록 '참조'만 복사한 것을 얕은 복사라고 한다.

```python
a = [1, 2, 3]
b = a
a[0] = 'surprise'
a
['surprise', 2, 3]
b
['surprise', 2, 3]
```

b는 단지 같은 리스트 객체 a를 참조하는 것이다.

그러므로 a 또는 b 리스트 내용을 변경하면 두 변수 모두에 반영된다.

## 복사하기: copy(), list(), 슬라이스 `[:]`
- copy() 메서드
- list() 변환 함수
- 슬라이스 `[:]`

를 사용하여 한 리스트를 새로운 리스트로 복사할 수 있다.

```python
a = [1, 2, 3]
b = a.copy()
c = list(a)
d = a[:]
```
- copy()로 리스트 b를 만든다.
- list() 변환 함수로 리스트 c를 만든다.
- a를 슬라이스해서 리스트 d를 만든다.

b, c, d 리스트는 a 리스트의 복사본이다.

그러나 이들은 자신만의 값을 가진 새로운 객체다.

원본 리스트 객체 `[1, 2, 3]`을 참조하는 아무런 참조가 없다.

복사본 b, c, d를 바꾸더라도 원본 리스트 a를 바꾸더라도 아무런 영향을 주지 않는다.

그리고 복사본 b를 바꾸더라도 c, d, a 리스트에는 아무런 영향을 주지 않는다.

**이렇게 새롭게 객체를 만드는 것을 깊은 복사라고 한다.**

깊은 복사는 리스트 내부 리스트, 딕셔너리 내부 리스트 등 내부에 있는 객체 모두 새롭게 만들어주는 작업을 한다.

모든 것 다 새롭게 복사. 그냥 독립적이 되어버린다.

그러나, copy(), list(), 슬라이스가 꼭 깊은 복사인 것은 아니다.

```python
a = [1, 2, [8, 9]]
b = a.copy()
c = list(a)
d = a[:]
```

깊은 복사가 잘 된 것 처럼 보인다.

그러나, 이제 한 번 하위에 중첩된 리스트의 항목을 변경해보자.

```python
a[2][1] = 10
a
[1, 2, [8, 10]]
b
[1, 2, [8, 10]]
c
[1, 2, [8, 10]]
d
[1, 2, [8, 10]]
```

**중첩되지 않은 리스트는 깊은 복사가 되었지만,**
**하위에 중첩된 리스트는 얕은 복사가 되었다.**

이 문제를 해결하기 위해 깊은 복사를 수행하는 `deepcopy()` 메서드를 사용하면 된다.

`deepcopy()` 메서드는 하위에 중첩된 리스트, 딕셔너리, 기타 다른 객체 모두를 깊은 복사한다.

```python
import copy
a = [1, 2, [8, 9]]
b = copy.deepcopy(a)
a
[1, 2, [8, 9]]
a[2][1] = 10
a
[1, 2, [8, 10]]
b
[1, 2, [8, 9]]
```

## 리스트 비교
리스트 비교는 튜플 비교와 똑같다.

`list1 == list2` 은 `list1` 리스트과 `list2` 리스트의 모든 요소가 순서대로 동일한지 확인한다.

`list1 >(=) list2` or `list1 <(=) list2` 은 리스트의 요소들의 크기를 순서대로 비교하여 리스트의 크기를 비교한다.

비교되는 리스트의 요소들은 같은 타입이어야 한다. 타입이 다른 경우, 비교는 의미가 없거나 예상치 못한 결과가 나올 수 있다.

만약 리스트에 속한 요소들의 타입이 문자열이라면, 파이썬은 요소를 차례대로 사전식(lexicographical)으로 비교한다.

즉, 문자열끼리의 비교가 그대로 적용된다.

## 리스트 순회하기: for...in
for in 문으로 리스트를 순회할 수 있다.

```python
a = [1, 2, 3]
for i in a:
	print(i)
1
2
3
```

## 여러 시퀀스 순회하기: zip()
`zip()` 함수는 여러 개의 순회 가능한(iterable) 객체를 인자로 받고,  순회 가능한 값(iterator)을 반환한다.

`zip()` 함수를 사용해서 두 항목의 시퀀스를 쉽게 생성할 수 있다.

`zip()` 함수를 사용하면 마치 옷의 지퍼를 올리는 것 처럼 양 측에 있는 데이터를 하나씩 차례로 짝을 지어준다.

```python
```py
>>> numbers = [1, 2, 3]
>>> letters = ["A", "B", "C"]
>>> for pair in zip(numbers, letters):
...     print(pair)
...
(1, 'A')
(2, 'B')
(3, 'C')
```

|표현|타입|설명|
|---|---|---|
|`zip([1, 2], ['a', 'b'])`|`zip` 객체|이터레이터|
|`list(zip(...))`|`list`|튜플들의 리스트|
|`next(zip(...))`|`tuple`|다음 쌍을 튜플로 반환|

zip() 함수에 의해 반환되는 값은 튜플이나 리스트 자신이 아니라 하나로 반환될 수 있는 순회 가능한 값이다.

즉, zip() 함수의 반환값은 zip 타입의 이터레이터이다.

zip() 함수의 반환값을 하나씩 꺼내면 이는 튜플이다.

즉, zip 타입의 이터레이터를 next() 하면 이는 튜플이라는 말이다.

list(zip(...)) 하면 리스트에 속한 튜플이 반환된다.

```python
list(zip((1, 2), (3, 4)))
[(1, 3), (2, 4)]
```

dict(zip(...)) 하면 key-value 딕셔너리가 생성된다.

```python
dict(zip((1, 2), (3, 4)))
{ 1: 2, 3: 4}
```

길이가 짧은 쪽 기준으로 동작한다.

```python
a = [1, 2, 3] b = ['a', 'b'] list(zip(a, b))  # [(1, 'a'), (2, 'b')]
```

길이가 안 맞으면 짧은 쪽까지만 결과를 만든다.

## 리스트 생성: append()
`append()` 를 사용하여 리스트를 생성할 수 있다.

```python
list = []
list.append(1)
list.append(2)
list.append(3)
list
[1, 2, 3]
```

## 리스트 생성: for...in
```python
list = []
for a in range(1, 6, 1):
	list.append(a)
list
[1, 2, 3, 4, 5]
```

## 리스트 생성: range()
`list()` 변환 함수의 인자로 `range()` 함수의 반환값을 전달하여 리스트를 생성할 수 있다.

```python
list = list(range(1, 6))
list
[1, 2, 3, 4, 5]
```

## 리스트 컴프리헨션(list comprehension)
컴프리헨션이란 새로운 자료형을 만드는 축약 문법이다.

컴프리헨션은 가변 타입만 제공한다.

`[]` 또는 list() 함수를 사용하여 리스트를 작성했다.

이번 절에서는 for/in 문의 순회 기능을 가진 리스트 컴프리헨션을 통해 리스트를 생성한다.

리스트 컴프리헨션을 사용해서 리스트를 만드는 것이 조금 더 파이써닉한 방법이다.

```python
[표현식 for 항목 in 이터러블 객체]
```

리스트 컴프리헨션으로 정수 리스트를 만들어보자.

```python
number_list = [number for number in range(1, 6)]
number_list
[1, 2, 3, 4, 5]
```

첫줄을 보면 리스트 값을 생성하는 첫 번째 number 변수가 필요하다.

이것은 순회 결과를 number_list 변수에 넣어준다.

두번째 number 변수는 for 문의 일부다.

다음 예제는 첫 번째 number 변수를 보여주기 위해 표현식을 바꿨다.

```python
number_list = [number - 1 for number in range(1, 6)]
number_list
[0, 1, 2, 3, 4]
```

리스트 컴프리헨션은 대괄호 안에 for 문이 있다.

이 컴프리헨션 예제는 실제로 이전 예제보다 조금 더 복잡하지만 더 많은 것을 수행한다.

리스트 컴프리헨션은 다음과 같이 조건 표현식을 포함할 수 있다.

```python
[표현식 for 항목 in 이터러블 객체 if 조건]
```

1과 5 사이에서 홀수 리스트를 만드는 새 컴프리헨션을 만들어보자(number % 2는 홀수일 때 True고, 짝수일때 False다.)

```python
a_list = [number for number in range(1, 6) if number % 2 == 0]
```
조건식이 True 일때만 number 변수의 값이 리스트의 요소로 추가되게 된다.

마지막으로 루프가 중첩될 수 있는 것처럼 컴프리헨션에서 루프에 상응하는 하나 이상의 for... 절을 사용할 수 있다.

```python
rows = range(1, 4)
cols = range(1, 3)
cells = [(row, col) for row in rows for col in cols]
for cell in cells:
	print(cell)
(1, 1)
(1, 2)
(2, 1)
(2, 2)
(3, 1)
(3, 2)

for row, col in cells: # 튜플 언패킹
	print(row, col)
```

`for row in rows` 이게 바깥 루프다.

`for col in cols` 이게 안쪽 루프다.

`[(row, col) ...]` 각 쌍을 튜플로 저장한다.

## 튜플 컴프리헨션은 없다.
가변 타입(리스트, 딕셔너리, 셋, ..)에는 컴프리헨션이 있다.
문자열과 튜플과 같은 불변 타입은 컴프리헨션이 없다.

```python
number_thing = (number for number in range(1, 6))
```
이것은 튜플 컴프리헨션이 아니라, 제너레이터 컴프리헨션이다.
제너레이터 컴프리헨션은 제너레이터 객체를 반환한다.
제너레이터는 반복문에 데이터를 제공하는 한 방법이다.

## 중첩 리스트
일반적인 리스트를 1차원 리스트라고 부른다.
리스트의 리스트를 중첩 리스트, 2차원 리스트라고 부른다.
중첩 리스트는 `list[offset][offset]` 이렇게 추출할 수 있다.
`list[offset1][offset2]`의 동작 원리는 이 표현식은 왼쪽부터 순차적으로 평가되서 참조되는 것이다.
즉,
```python
temp = list[offset1]
result = temp[offset2]
```
이걸 한 줄로 줄이면 `list[offset1][offset2]`인 거다.

## 튜플 vs 리스트
튜플은 리스트의 `append(), insert()` 등과 같은 함수가 없고, 튜플을 생성한 후에는 수정할 수 없어서 함수의 수가 매우 적다.

그렇다면 리스트를 사용하지 않고, 튜플을 사용하는 이유는 뭘까?

- 튜플은 더 적은 공간을 사용한다.
- 실수로 튜플의 항목이 손상될 염려가 없다.
- 튜플을 딕셔너리 키로 사용할 수 있다.
- 네임드튜플은 객체의 단순한 대안이 될 수 있다.

그러나, 일반적으로 리스트와 딕셔너리를 튜플보다 더 많이 사용한다.